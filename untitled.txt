getgenv().namehub = "Moon | .gg/moondiety"


local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/skkdjdjdhd/Goon/refs/heads/main/V"))()

local main = Library.new()
local farmTab = main:create_tab('Farm', "12234147901")
local tab0 = main:create_tab('Main', "7485051715")
local tab2 = main:create_tab('Utility', "13321880274")
local bringTab = main:create_tab('Bring', "17703459601")
local tab = main:create_tab('Teleport', "12941020168")
local hitboxTab = main:create_tab('Hitbox', "96932333352456")
local tab3 = main:create_tab('ESP', "16149075788")
local trollTab = main:create_tab('Troll', "13321880274")
local settingsTab = main:create_tab('SETTINGS', "12941020168")



local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Workspace = game:GetService("Workspace")
local remoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer

local CharacterFolder = Workspace:FindFirstChild("Characters") or Workspace

local player = game.Players.LocalPlayer

farmTab.create_title({
    name = '== Don\'t Click Features Below If not Farming ==',
    section = 'left'
})

farmTab.create_button({
    name = 'AFK Win/Days Farm',
    flag = 'afk_farm',
    section = 'left',
    callback = function()
       getgenv().FarmGodModeEnabled = true
        coroutine.wrap(function()
            while getgenv().FarmGodModeEnabled do
                local args = {-1/0}
                pcall(function()
                    game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("DamagePlayer"):FireServer(unpack(args))
                end)
                task.wait(0.1)
            end
        end)()
        print("GodMode Activated for Farm")

        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
        local Workspace = game:GetService("Workspace")
        local RunService = game:GetService("RunService")
        local Lighting = game:GetService("Lighting")
        local UserInputService = game:GetService("UserInputService")
        local VirtualUser = game:GetService("VirtualUser")
        local ContextActionService = game:GetService("ContextActionService")


        local safezoneBaseplates = {}
        local baseplateSize = Vector3.new(2048, 5, 2048)
        local baseY = 130
        local centerPos = Vector3.new(0, baseY, 0)


        for dx = -1, 1 do
            for dz = -1, 1 do
                local pos = centerPos + Vector3.new(dx * baseplateSize.X, 0, dz * baseplateSize.Z)
                local baseplate = Instance.new("Part")
                baseplate.Name = "SafeZoneBaseplate"
                baseplate.Size = baseplateSize
                baseplate.Position = pos
                baseplate.Anchored = true
                baseplate.CanCollide = true
                baseplate.Transparency = 1
                baseplate.Color = Color3.fromRGB(255, 255, 255)
                baseplate.Parent = Workspace
                table.insert(safezoneBaseplates, baseplate)
            end
        end

        local function teleportToTarget(cf, duration)
            local char = LocalPlayer.Character
            if not char then return end
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            if duration and duration > 0 then
                local ts = game:GetService("TweenService")
                local info = TweenInfo.new(duration, Enum.EasingStyle.Linear)
                local goal = { CFrame = cf }
                local tween = ts:Create(hrp, info, goal)
                tween:Play()
            else
                hrp.CFrame = cf
            end
        end

        local function stringToCFrame(str)
            local x, y, z = str:match("([^,]+),%s*([^,]+),%s*([^,]+)")
            return CFrame.new(tonumber(x), tonumber(y), tonumber(z))
        end

        local storyCoords = {
            { "[campsite] camp site", "0, 8, -0"},
            { "[safezone] safe zone", "0, 140, -0" }
        }

        for _, entry in ipairs(storyCoords) do
            local name, coord = entry[1], entry[2]
            if name:lower():find("safezone") then
                teleportToTarget(stringToCFrame(coord), 0.1)
                break
            end
        end


        LocalPlayer.CharacterAdded:Connect(function(char)
            task.wait(1)
            HumanoidRootPart = char:WaitForChild("HumanoidRootPart")
            for _, entry in ipairs(storyCoords) do
                local name, coord = entry[1], entry[2]
                if name:lower():find("safezone") then
                    for i = 1, 5 do
                        teleportToTarget(stringToCFrame(coord), 0.1)
                        task.wait(0.1)
                    end
                    break
                end
            end
        end)


        local chopAuraToggle = false
        local chopAuraConnection
        local chopAuraRadius = 600
        local currentammount = 0

        local toolsDamageIDs = {
            ["Spear"] = "196_8999010016",
            ["Chainsaw"] = "647_8992824875",
            ["Strong Axe"] = "116_7367831688",
            ["Good Axe"] = "112_7367831688",
            ["Old Axe"] = "3_7367831688"
        }

        local function getAxe()
            local inventory = LocalPlayer:FindFirstChild("Inventory")
            if not inventory then return end
            
            for toolName, damageID in pairs(toolsDamageIDs) do
                if toolName:match("Axe") then
                    local tool = inventory:FindFirstChild(toolName)
                    if tool then
                        return tool, damageID
                    end
                end
            end
        end

        local function getTrees()
            local trees = {}
            local map = Workspace:FindFirstChild("Map")
            if not map then return trees end
            
            local locations = {
                map:FindFirstChild("Foliage"),
                map:FindFirstChild("Landmarks")
            }
            
            for _, location in ipairs(locations) do
                if location then
                    for _, obj in ipairs(location:GetChildren()) do
                        if obj:IsA("Model") and obj.Name == "Small Tree" then
                            local trunk = obj:FindFirstChild("Trunk")
                            if trunk and trunk:IsA("BasePart") then
                                table.insert(trees, {model = obj, trunk = trunk})
                            end
                        end
                    end
                end
            end
            
            return trees
        end

        local function chopTree(tree, tool, rootPart)
            if not tree.trunk or not tree.model then return end
            
            if (tree.trunk.Position - rootPart.Position).Magnitude <= chopAuraRadius then
                currentammount = currentammount + 1
                RemoteEvents.ToolDamageObject:InvokeServer(
                    tree.model,
                    tool,
                    tostring(currentammount) .. "_7367831688",
                    CFrame.new(-2.962610244751, 4.5547881126404, -75.950843811035, 0.89621275663376, -1.3894891459643e-08, 0.44362446665764, -7.994568895775e-10, 1, 3.293635941759e-08, -0.44362446665764, -2.9872644802253e-08, 0.89621275663376)
                )
            end
        end

        local function startAutoChop()
            if chopAuraConnection then
                chopAuraConnection:Disconnect()
            end
            
            chopAuraToggle = true
            
            local lastEquip = 0
            local equipped = false
            local lastChop = 0
            
            chopAuraConnection = RunService.Heartbeat:Connect(function()
                local character = LocalPlayer.Character
                local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                if not rootPart then return end

                local tool, _ = getAxe()
                if not tool then return end

                local now = tick()
                if not equipped and now - lastEquip > 0.1 then
                    RemoteEvents.EquipItemHandle:FireServer("FireAllClients", tool)
                    equipped = true
                    lastEquip = now
                end

                if now - lastChop > 0.2 then
                    local trees = getTrees()
                    for _, tree in ipairs(trees) do
                        task.spawn(function()
                            chopTree(tree, tool, rootPart)
                        end)
                    end
                    lastChop = now
                end
            end)
        end


        local campfireDropPos = Vector3.new(0, 19, 0)
        local fuelItems = { "Log", "Coal" }
        local itemsFolder = Workspace:WaitForChild("Items")

        local function moveItemToCampfire(item)
            local part = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")
            if not part then return end
            if not item.PrimaryPart then
                pcall(function() item.PrimaryPart = part end)
            end
            pcall(function()
                RemoteEvents.RequestStartDraggingItem:FireServer(item)
                task.wait(0.05)
                item:SetPrimaryPartCFrame(CFrame.new(campfireDropPos))
                task.wait(0.05)
                RemoteEvents.StopDraggingItem:FireServer(item)
            end)
        end

        local function startAutoFuel()
            coroutine.wrap(function()
                while true do
                    for _, itemName in ipairs(fuelItems) do
                        for _, item in ipairs(itemsFolder:GetChildren()) do
                            if item.Name == itemName then
                                moveItemToCampfire(item)
                            end
                        end
                    end
                    task.wait(2)
                end
            end)()
        end


        local killAuraToggle = false
        local killAuraConnection
        local auraRadius = 300

        local function getWeapon()
            local inventory = LocalPlayer:FindFirstChild("Inventory")
            if not inventory then return end
            
            for toolName, damageID in pairs(toolsDamageIDs) do
                local tool = inventory:FindFirstChild(toolName)
                if tool then
                    return tool, damageID
                end
            end
        end

        local function attackMob(mob, tool, damageID, rootPart)
            local mobPart = mob:FindFirstChildWhichIsA("BasePart")
            if not mobPart then return end
            
            if (mobPart.Position - rootPart.Position).Magnitude <= auraRadius then
                RemoteEvents.ToolDamageObject:InvokeServer(
                    mob,
                    tool,
                    damageID,
                    CFrame.new(mobPart.Position)
                )
            end
        end

        local function startKillAura()
            if killAuraConnection then
                killAuraConnection:Disconnect()
            end
            
            killAuraToggle = true
            
            local lastEquip = 0
            local equipped = false
            
            killAuraConnection = RunService.Heartbeat:Connect(function()
                local character = LocalPlayer.Character
                local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                if not rootPart then return end

                local tool, damageID = getWeapon()
                if not tool or not damageID then return end

                local now = tick()
                if not equipped and now - lastEquip > 0.1 then
                    RemoteEvents.EquipItemHandle:FireServer("FireAllClients", tool)
                    equipped = true
                    lastEquip = now
                end

                for _, mob in ipairs(Workspace.Characters:GetChildren()) do
                    if mob:IsA("Model") and mob ~= character then
                        task.spawn(function()
                            attackMob(mob, tool, damageID, rootPart)
                        end)
                    end
                end
            end)
            print(".gg/moondiety")
        end


        local cookItems = { "Morsel", "Steak" }

        local function startAutoCook()
            coroutine.wrap(function()
                while true do
                    for _, itemName in ipairs(cookItems) do
                        for _, item in ipairs(itemsFolder:GetChildren()) do
                            if item.Name == itemName then
                                moveItemToCampfire(item)
                                task.wait(0.2)
                            end
                        end
                    end
                    task.wait(2)
                end
            end)()
        end


        local bringItems = { "Cooked Morsel", "Cooked Steak" }
        local bringInterval = 120 

        local function teleportItemToPlayer(item)
            local character = LocalPlayer.Character
            if not character then return end
            
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            
            local part = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")
            if not part then return end
            
            if not item.PrimaryPart then
                pcall(function() item.PrimaryPart = part end)
            end
            
            pcall(function()
                RemoteEvents.RequestStartDraggingItem:FireServer(item)
                task.wait(0.05)
                item:SetPrimaryPartCFrame(CFrame.new(hrp.Position + Vector3.new(0, 3, 0)))
                task.wait(0.05)
                RemoteEvents.StopDraggingItem:FireServer(item)
            end)
        end

        local function startBringItem()
            coroutine.wrap(function()
                while true do
                    for _, itemName in ipairs(bringItems) do
                        for _, item in ipairs(itemsFolder:GetChildren()) do
                            if item.Name == itemName then
                                teleportItemToPlayer(item)
                                task.wait(0.1)
                            end
                        end
                    end
                    task.wait(bringInterval)
                end
            end)()
            print(".gg/moondiety")
        end


        local eatFoods = { "Cooked Steak", "Cooked Morsel" }
        local hungerThreshold = 0.95 

        local function getHungerBar()
            local success, hungerBar = pcall(function()
                return LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("Interface")
                    :WaitForChild("StatBars"):WaitForChild("HungerBar"):WaitForChild("Bar")
            end)
            return success and hungerBar or nil
        end

        local hungerBar = getHungerBar()

        local function canEat()
            if not hungerBar then return false end
            return hungerBar.Size.X.Scale < hungerThreshold
        end

        local function consumeFood(food)
            pcall(function()
                RemoteEvents.RequestConsumeItem:InvokeServer(food)
            end)
        end

        local function startAutoEat()
            coroutine.wrap(function()
                while true do
                    if canEat() then
                        local foodList = {}
                        for _, item in ipairs(itemsFolder:GetChildren()) do
                            if table.find(eatFoods, item.Name) then
                                table.insert(foodList, item)
                            end
                        end

                        if #foodList > 0 then
                            local food = foodList[math.random(1, #foodList)]
                            consumeFood(food)
                        end
                    end
                    task.wait(1)
                end
            end)()
            print(".gg/moondiety")
        end


        local originalFogStart = Lighting.FogStart
        local originalFogEnd = Lighting.FogEnd
        local originalFogColor = Lighting.FogColor

        local function removeFog()
            pcall(function()
                Lighting.FogStart = 100000
                Lighting.FogEnd = 100000
                Lighting.FogColor = Color3.new(1, 1, 1)
            end)
        end

        local function restoreFog()
            pcall(function()
                Lighting.FogStart = originalFogStart or 0
                Lighting.FogEnd = originalFogEnd or 100000
                Lighting.FogColor = originalFogColor or Color3.new(1, 1, 1)
            end)
        end


        removeFog()

        task.spawn(function()
            while true do
                removeFog()
                task.wait(1)
            end
        end)

        print("No Fog Activated")


        local function antiAfkLoop()
            
            task.spawn(function()
                while true do
                    pcall(function()
                     
                        local mousePos = UserInputService:GetMouseLocation()
                        VirtualUser:MoveMouse(Vector2.new(mousePos.X + 1, mousePos.Y + 1))
                        VirtualUser:MoveMouse(Vector2.new(mousePos.X - 1, mousePos.Y - 1))
                        
                        
                        VirtualUser:SendKeyEvent(true, "W", false, nil)
                        task.wait(0.1)
                        VirtualUser:SendKeyEvent(false, "W", false, nil)
                        
                        VirtualUser:SendMouseButtonEvent(100, 100, 1, true, nil, 0)
                        task.wait(0.1)
                        VirtualUser:SendMouseButtonEvent(100, 100, 1, false, nil, 0)
                    end)
                    task.wait(20) 
                end
            end)
            
            
            task.spawn(function()
                while true do
                    pcall(function()
                        local afkFrame = LocalPlayer:FindFirstChild("PlayerGui") and 
                                       LocalPlayer.PlayerGui:FindFirstChild("AFKFrame")
                        if afkFrame then
                            
                            local continueButton = afkFrame:FindFirstChild("ContinueButton") or 
                                                 afkFrame:FindFirstChild("OKButton") or 
                                                 afkFrame:FindFirstChild("AcceptButton")
                            if continueButton and continueButton:IsA("GuiButton") then
                                continueButton:GetPropertyChangedSignal("AbsolutePosition"):Wait()
                                VirtualUser:ClickButton2(continueButton)
                                VirtualUser:ClickButton1(continueButton)
                            end
                        end
                    end)
                    task.wait(5)
                end
            end)
            
            
            task.spawn(function()
                while true do
                    pcall(function()
                        ContextActionService:BindAction("AntiAFK", function() end, false, Enum.KeyCode.Unknown)
                        ContextActionService:UnbindAction("AntiAFK")
                    end)
                    task.wait(15)
                end
            end)
        end


        antiAfkLoop()

        print("Anti AFK Activated")

        task.spawn(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/goondiety/ESP-LIB/refs/heads/main/FarmLoading.lua"))()
        end)

        task.delay(3, startAutoChop)
        task.delay(3 + 8, startAutoFuel)
        task.delay(3 + 8 + 8, startKillAura)
        task.delay(3 + 8 + 8 + 8, startAutoCook)
        task.delay(3 + 8 + 8 + 8 + 8, startBringItem)
        task.delay(3 + 8 + 8 + 8 + 8 + 8, startAutoEat)
    end
})

farmTab.create_button({
    name = 'Diamond Farm [V2]',
    flag = 'diamond_farm',
    section = 'left',
    callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/hash0tobash8/Core/refs/heads/main/f"))()
    end
})
farmTab.create_title({
    name = '== FOR SUGGESTIONS/BUGS ==',
    section = 'left'
})
farmTab.create_button({
    name = 'Join Discord like a GOOD BOY',
    section = 'left',
    enabled = false,
    callback = function()
        setclipboard('https://discord.gg/moondiety')
    end
})
farmTab.create_title({
    name = '== GUI WINDOW TOGGLE ==',
    section = 'left'
})
farmTab.create_keybind({
    name = "UI Toggle Keybind",
    flag = "toggleui",
    section = "left",
    keycode = Enum.KeyCode.M,
    callback = function(key)
        print("UI toggled with key:", key)
    end
})


local ESPSettings = {
    ItemESP = {
        Enabled = false,
        Items = {
            "All",
            "Bandage", "Bolt", "Broken Fan", "Broken Microwave", "Cake", "Carrot", 
            "Chair", "Coal", "Coin Stack", "Cooked Morsel", "Cooked Steak", 
            "Fuel Canister", "Iron Body", "Leather Armor", "Log", "MadKit", 
            "Metal Chair", "MedKit", "Old Car Engine", "Old Flashlight", "Old Radio", 
            "Revolver", "Revolver Ammo", "Rifle", "Rifle Ammo", "Morsel", 
            "Sheet Metal", "Steak", "Tyre", "Washing Machine"
        },
        Color = Color3.fromRGB(0, 255, 0),
        Selected = {}
    },
    EntityESP = {
        Enabled = false,
        Entities = {
            "All",
            "Bunny", "Wolf", "Alpha Wolf", "Bear", "Cultist", 
            "Crossbow Cultist", "Alien"
        },
        Color = Color3.fromRGB(255, 0, 0),
        Selected = {}
    },
    MaxDistance = 300
}

local ESPObjects = {}
local ESPConnections = {}

local function createESPText(part, text, color)
    if not part or part:FindFirstChild("ESPText") then return end

    local esp = Instance.new("BillboardGui")
    esp.Name = "ESPText"
    esp.Adornee = part
    esp.Size = UDim2.new(0, 100, 0, 20)
    esp.StudsOffset = Vector3.new(0, 2.5, 0)
    esp.AlwaysOnTop = true
    esp.MaxDistance = ESPSettings.MaxDistance

    local label = Instance.new("TextLabel")
    label.Parent = esp
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = color
    label.TextStrokeTransparency = 0.2
    label.TextScaled = true
    label.Font = Enum.Font.GothamBold

    esp.Parent = part
    return esp
end

local function updateESP(espType)
    local settings = ESPSettings[espType]
    local container = espType == "ItemESP" and Workspace.Items or Workspace.Characters
    

    for _, obj in ipairs(container:GetChildren()) do
        local part = obj:FindFirstChildWhichIsA("BasePart")
        if part then
            local esp = part:FindFirstChild("ESPText")
            if esp then esp:Destroy() end
        end
    end
    
   
    if settings.Enabled then
        for _, obj in ipairs(container:GetChildren()) do
            if settings.Selected["All"] or settings.Selected[obj.Name] then
                local part = obj:FindFirstChildWhichIsA("BasePart")
                if part then
                    createESPText(part, obj.Name, settings.Color)
                end
            end
        end
    end
end

local killAuraToggle = false
local killAuraConnection
local auraRadius = 100

local toolsDamageIDs = {
    ["Spear"] = "196_8999010016",
    ["Chainsaw"] = "647_8992824875",
    ["Strong Axe"] = "116_7367831688",
    ["Good Axe"] = "112_7367831688",
    ["Old Axe"] = "3_7367831688"
}

local function getWeapon()
    local inventory = LocalPlayer:FindFirstChild("Inventory")
    if not inventory then return end
    
    for toolName, damageID in pairs(toolsDamageIDs) do
        local tool = inventory:FindFirstChild(toolName)
        if tool then
            return tool, damageID
        end
    end
end

local function attackMob(mob, tool, damageID, rootPart)
    local mobPart = mob:FindFirstChildWhichIsA("BasePart")
    if not mobPart then return end
    
    if (mobPart.Position - rootPart.Position).Magnitude <= auraRadius then
        remoteEvents.ToolDamageObject:InvokeServer(
            mob,
            tool,
            damageID,
            CFrame.new(mobPart.Position)
        )
    end
end
tab0.create_title({
    name = '== GODMODE ==',
    section = 'left'
})

getgenv().GodModeEnabled = true

tab0.create_toggle({
    name = 'Invincible [No Damage]',
    flag = 'godmode_toggle',
    section = 'left',
    enabled = true,
    callback = function(state)
        getgenv().GodModeEnabled = state
        if state then
            print("GodMode Activated")
        else
            print("GodMode Deactivated")
        end
    end
})


coroutine.wrap(function()
    while true do
        if getgenv().GodModeEnabled then
            local args = {-1/0}
            pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("DamagePlayer"):FireServer(unpack(args))
            end)
        end
        task.wait(0.1)
    end
end)()
tab0.create_title({
    name = '== COMBAT ==',
    section = 'left'
})
tab0.create_toggle({ 
    name = 'Kill Aura',
    flag = 'killaura_enabled',
    section = 'left',
    enabled = false,

    callback = function(state)
        killAuraToggle = state
        if state then
            local lastEquip = 0
            local equipped = false
            
            killAuraConnection = RunService.Heartbeat:Connect(function()
                local character = LocalPlayer.Character
                local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                if not rootPart then return end

                local tool, damageID = getWeapon()
                if not tool or not damageID then return end

                local now = tick()
                if not equipped and now - lastEquip > 0.1 then
                    remoteEvents.EquipItemHandle:FireServer("FireAllClients", tool)
                    equipped = true
                    lastEquip = now
                end

                for _, mob in ipairs(Workspace.Characters:GetChildren()) do
                    if mob:IsA("Model") and mob ~= character then
                        task.spawn(function()
                            attackMob(mob, tool, damageID, rootPart)
                        end)
                    end
                end
            end)
        else
            if killAuraConnection then
                killAuraConnection:Disconnect()
                killAuraConnection = nil
            end
        end
    end
})



tab0.create_slider({ 
    name = 'Kill Aura Radius',
    flag = 'aura_radius',
    section = 'left',
    value = 100,
    minimum_value = 20,
    maximum_value = 600,

    callback = function(value)
        auraRadius = value
    end
})
local itemsFolder = Workspace:WaitForChild("Items")
local function getRandomCoord()
    if math.random() < 0.5 then
        return math.random(-200, -100)
    else
        return math.random(100, 200)
    end
end

local chopAuraToggle = false
local chopAuraConnection
local chopAuraRadius = 50
local currentammount = 0

local function getAxe()
    local inventory = LocalPlayer:FindFirstChild("Inventory")
    if not inventory then return end
    
    for toolName, damageID in pairs(toolsDamageIDs) do
        if toolName:match("Axe") then
            local tool = inventory:FindFirstChild(toolName)
            if tool then
                return tool, damageID
            end
        end
    end
end

local function getTrees()
    local trees = {}
    local map = Workspace:FindFirstChild("Map")
    if not map then return trees end
    
    local locations = {
        map:FindFirstChild("Foliage"),
        map:FindFirstChild("Landmarks")
    }
    
    for _, location in ipairs(locations) do
        if location then
            for _, obj in ipairs(location:GetChildren()) do
                if obj:IsA("Model") and obj.Name == "Small Tree" then
                    local trunk = obj:FindFirstChild("Trunk")
                    if trunk and trunk:IsA("BasePart") then
                        table.insert(trees, {model = obj, trunk = trunk})
                    end
                end
            end
        end
    end
    
    return trees
end

local function chopTree(tree, tool, rootPart)
    if not tree.trunk or not tree.model then return end
    
    if (tree.trunk.Position - rootPart.Position).Magnitude <= chopAuraRadius then
        currentammount = currentammount + 1
        remoteEvents.ToolDamageObject:InvokeServer(
            tree.model,
            tool,
            tostring(currentammount) .. "_7367831688",
            CFrame.new(-2.962610244751, 4.5547881126404, -75.950843811035, 0.89621275663376, -1.3894891459643e-08, 0.44362446665764, -7.994568895775e-10, 1, 3.293635941759e-08, -0.44362446665764, -2.9872644802253e-08, 0.89621275663376)
        )
    end
end

tab0.create_toggle({
    name = 'Auto Chop',
    flag = 'chopaura_enabled',
    section = 'left',
    enabled = false,
    callback = function(state)
        chopAuraToggle = state
        if state then
            local lastEquip = 0
            local equipped = false
            local lastChop = 0
            
            chopAuraConnection = RunService.Heartbeat:Connect(function()
                local character = LocalPlayer.Character
                local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                if not rootPart then return end

                local tool, _ = getAxe()
                if not tool then return end

                local now = tick()
                if not equipped and now - lastEquip > 0.1 then
                    remoteEvents.EquipItemHandle:FireServer("FireAllClients", tool)
                    equipped = true
                    lastEquip = now
                end

                if now - lastChop > 0.2 then
                    local trees = getTrees()
                    for _, tree in ipairs(trees) do
                        task.spawn(function()
                            chopTree(tree, tool, rootPart)
                        end)
                    end
                    lastChop = now
                end
            end)
        else
            if chopAuraConnection then
                chopAuraConnection:Disconnect()
                chopAuraConnection = nil
            end
        end
    end
})

tab0.create_slider({
    name = 'Chop Aura Radius',
    flag = 'chopaura_radius',
    section = 'left',
    value = 50,
    minimum_value = 20,
    maximum_value = 600,
    callback = function(value)
        chopAuraRadius = value
    end
})




local campfireDropPos = Vector3.new(0, 19, 0)
local campfireFuelItems = { "Log", "Coal", "Fuel Canister", "Oil Barrel", "Biofuel" }

local greedyFuelEnabled = {}
local autoFuelEnabled = {}

local function moveItemToCampfire(item)
    local part = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")
    if not part then return end
    if not item.PrimaryPart then
        pcall(function() item.PrimaryPart = part end)
    end
    pcall(function()
        remoteEvents.RequestStartDraggingItem:FireServer(item)
        task.wait(0.05)
        item:SetPrimaryPartCFrame(CFrame.new(campfireDropPos))
        task.wait(0.05)
        remoteEvents.StopDraggingItem:FireServer(item)
    end)
end

local function processFuel(enabledTable)
    for name, enabled in pairs(enabledTable) do
        if enabled then
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == name then
                    moveItemToCampfire(item)
                end
            end
        end
    end
end

tab0.create_title({
    name = '== AUTOMATIONS ==',
    section = 'left'
})
local campfireFuelItems = { "All", "Log", "Coal", "Fuel Canister", "Oil Barrel", "Biofuel" }
local greedyFuelEnabled = false
local selectedFuels = {}

tab0.create_toggle({
    name = "Auto Fuel",
    flag = "greedy_fuel_toggle",
    section = "left",
    enabled = false,
    callback = function(state)
        greedyFuelEnabled = state
        if state then
            coroutine.wrap(function()
                while greedyFuelEnabled do
                    for itemName, enabled in pairs(selectedFuels) do
                        if enabled then
                            for _, item in ipairs(itemsFolder:GetChildren()) do
                                if item.Name == itemName then
                                    moveItemToCampfire(item)
                                end
                            end
                        end
                    end
                    task.wait(2)
                end
            end)()
        end
    end
})

tab0.create_multidropdown({
    name = "Select Fuels",
    flag = "greedy_fuel_dropdown",
    section = "left",
    option = "Select fuels",
    options = campfireFuelItems,
    multi = true,
    callback = function(selected)
        selectedFuels = {}
        if table.find(selected, "All") then
            for _, item in ipairs(campfireFuelItems) do
                if item ~= "All" then
                    selectedFuels[item] = true
                end
            end
        else
            for _, name in ipairs(selected) do
                selectedFuels[name] = true
            end
        end
    end
})

local itemsFolder = workspace:WaitForChild("Items")
local remoteEvents = game.ReplicatedStorage:WaitForChild("RemoteEvents")


local machineDropPos = Vector3.new(21, 16, -5)
local allCraftableItems = {
    "UFO Junk", "UFO Component", "Old Car Engine", "Broken Fan",
    "Old Microwave", "Bolt", "Log", "Cultist Gem", "Sheet Metal",
    "Old Radio", "Tyre", "Washing Machine", "Cultist Experiment",
    "Cultist Component", "Gem of the Forest Fragment", "Broken Microwave"
}

local autoCraftActive = false     
local selectedCraftItems = {}      
local autoCraftLoop = nil          


local function moveItemToMachine(item)
    if not item or not item.Parent then return end
    local part = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")
    if not part then return end

    if not item.PrimaryPart and item:IsA("Model") then
        pcall(function() item.PrimaryPart = part end)
    end

    pcall(function()
        remoteEvents.RequestStartDraggingItem:FireServer(item)
        item:SetPrimaryPartCFrame(CFrame.new(machineDropPos))
        remoteEvents.StopDraggingItem:FireServer(item)
    end)
end


local function autoCraftMainLoop()
    while autoCraftActive do
        local itemsToProcess = {}
        
        if selectedCraftItems["All"] then
            itemsToProcess = allCraftableItems
        else
            for itemName, isSelected in pairs(selectedCraftItems) do
                if isSelected then
                    table.insert(itemsToProcess, itemName)
                end
            end
        end

        
        for _, itemName in ipairs(itemsToProcess) do
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == itemName then
                    moveItemToMachine(item)
                    task.wait(0.1)
                end
            end
        end
        task.wait(2.5)
    end
    autoCraftLoop = nil 
end


tab0.create_toggle({
    name = "Activate Auto Craft",
    flag = "autocraft_activate",
    section = "left",
    enabled = false,
    callback = function(state)
        autoCraftActive = state
       
        if state and not autoCraftLoop then
            autoCraftLoop = task.spawn(autoCraftMainLoop)
        end
    end
})


tab0.create_multidropdown({
    name = "Auto Craft Items",
    flag = "autocraft_selection",
    section = "left",
    option = "Select items",
    options = (function()
      
        local craftOptions = {"All"}
        for _, item in ipairs(allCraftableItems) do
            table.insert(craftOptions, item)
        end
        return craftOptions
    end)(),
    multi = true,
    callback = function(selectedOptions)
       
        table.clear(selectedCraftItems)
        for _, name in ipairs(selectedOptions) do
            selectedCraftItems[name] = true
        end
    end
})


local allCookableItems = { "Morsel", "Steak" }

local autoCookActive = false      
local selectedCookItems = {}     
local autoCookLoop = nil          


local function autoCookMainLoop()
    while autoCookActive do
        local itemsToProcess = {}
      
        if selectedCookItems["All"] then
            itemsToProcess = allCookableItems
        else
            for itemName, isSelected in pairs(selectedCookItems) do
                if isSelected then
                    table.insert(itemsToProcess, itemName)
                end
            end
        end

       
        for _, itemName in ipairs(itemsToProcess) do
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if item.Name == itemName then
                    -- We reuse the moveItemToCampfire function coz why not
                    moveItemToCampfire(item)
                    task.wait(0.2) 
                end
            end
        end
        task.wait(2)
    end
    autoCookLoop = nil 
end


tab0.create_toggle({
    name = "Activate Auto Cook",
    flag = "autocook_activate",
    section = "left",
    enabled = false,
    callback = function(state)
        autoCookActive = state
       
        if state and not autoCookLoop then
            autoCookLoop = task.spawn(autoCookMainLoop)
        end
    end
})


tab0.create_multidropdown({
    name = "Auto Cook Items",
    flag = "autocook_selection",
    section = "left",
    option = "Select raw food",
    options = (function()
      
        local cookOptions = {"All"}
        for _, item in ipairs(allCookableItems) do
            table.insert(cookOptions, item)
        end
        return cookOptions
    end)(),
    multi = true,
    callback = function(selectedOptions)
        
        table.clear(selectedCookItems)
        for _, name in ipairs(selectedOptions) do
            selectedCookItems[name] = true
        end
    end
})



local itemsFolder = workspace:WaitForChild("Items")
local remoteEvents = game.ReplicatedStorage:WaitForChild("RemoteEvents")

local biofuelItems = {
    "Carrot", "Cooked Morsel", "Morsel", "Steak", "Cooked Steak", "Log"
}



local function moveItemTo(pos, item)
    local part = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")
    if not part then return end

    if not item.PrimaryPart then
        pcall(function() item.PrimaryPart = part end)
    end

    pcall(function()
        remoteEvents.RequestStartDraggingItem:FireServer(item)
        task.wait(0.05)
        item:SetPrimaryPartCFrame(CFrame.new(pos))
        task.wait(0.05)
        remoteEvents.StopDraggingItem:FireServer(item)
    end)
end

coroutine.wrap(function()
    local processorPos = nil

    while true do
        if not processorPos then
            local processor = workspace:FindFirstChild("Structures")
                and workspace.Structures:FindFirstChild("Biofuel Processor")
            local part = processor and processor:FindFirstChild("Part")
            if part then
                processorPos = part.Position + Vector3.new(0, 5, 0)
            end
        end

        if processorPos then
            for itemName, _ in pairs(enabledBiofuelItems) do
                for _, item in ipairs(itemsFolder:GetChildren()) do
                    if item.Name == itemName then
                        moveItemTo(processorPos, item)
                    end
                end
            end
        end

        task.wait(2)
    end
end)()
tab0.create_title({
    name = '== AUTO EAT (USE AUTO COOK FIRST)  ==',
    section = 'left'
})
local itemsFolder = workspace:WaitForChild("Items")


local autoEatFoods = { "Cooked Steak", "Cooked Morsel" }

local autoEatEnabled = false
local autoEatHPEnabled = false
local autoFuelEnabled = false

local eatDelay = 3
local hpThreshold = 0.5
local fuelDelay = 5

tab0.create_toggle({
    name = "Auto Eat (Time Based)",
    flag = "auto_eat_time",
    section = "left",
    enabled = false,
    callback = function(state)
        autoEatEnabled = state
    end
})

tab0.create_slider({
    name = "Eat Delay (seconds)",
    flag = "eat_delay",
    section = "left",
    value = 3,
    minimum_value = 1,
    maximum_value = 10,
    callback = function(value)
        eatDelay = value
    end
})

tab0.create_toggle({
    name = "Auto Eat (HP Based)",
    flag = "auto_eat_hp",
    section = "left",
    enabled = false,
    callback = function(state)
        autoEatHPEnabled = state
    end
})

tab0.create_slider({
    name = "Eat if Hunger Below (%)",
    flag = "eat_hunger_threshold",
    section = "left",
    value = 50,
    minimum_value = 10,
    maximum_value = 100,
    callback = function(value)
        hpThreshold = value / 100
    end
})


coroutine.wrap(function()
    while true do
        if autoEatEnabled then
            local foodList = {}
            for _, item in ipairs(itemsFolder:GetChildren()) do
                if table.find(autoEatFoods, item.Name) then
                    table.insert(foodList, item)
                end
            end

            if #foodList > 0 then
                local food = foodList[math.random(1, #foodList)]
                pcall(function() game.ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestConsumeItem"):InvokeServer(food) end)
            end
        end
        task.wait(eatDelay)
    end
end)()

local player = game.Players.LocalPlayer
local function safeGetGui(...)
    local current = ...
    for i = 2, select("#", ...) do
        local name = select(i, ...)
        current = current:FindFirstChild(name)
        if not current then return nil end
    end
    return current
end

local bar = safeGetGui(player, "PlayerGui", "Interface", "StatBars", "HungerBar", "Bar")
if bar then

local hungerBar = player:WaitForChild("PlayerGui"):WaitForChild("Interface")
    :WaitForChild("StatBars"):WaitForChild("HungerBar"):WaitForChild("Bar")



coroutine.wrap(function()
    while true do
        if autoEatHPEnabled then
            if hungerBar.Size.X.Scale <= hpThreshold then
                repeat
                    local foodList = {}
                    for _, item in ipairs(itemsFolder:GetChildren()) do
                        if table.find(autoEatFoods, item.Name) then
                            table.insert(foodList, item)
                        end
                    end

                    if #foodList > 0 then
                        local food = foodList[math.random(1, #foodList)]
                        pcall(function() game.ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("RequestConsumeItem"):InvokeServer(food) end)
                    else
                        break
                    end

                    task.wait(1)
                until hungerBar.Size.X.Scale >= 0.99 or not autoEatHPEnabled
            end
        end
        task.wait(3)
    end
end)()
end
 
local treeFarmActive = false

local function getAllTrees()
    local map = Workspace:FindFirstChild("Map")
    if not map then return {} end
    local landmarks = map:FindFirstChild("Landmarks") or map:FindFirstChild("Foliage")
    if not landmarks then return {} end

    local trees = {}
    for _, tree in ipairs(landmarks:GetChildren()) do
        if tree.Name == "Small Tree" and tree:IsA("Model") then
            local trunk = tree:FindFirstChild("Trunk") or tree.PrimaryPart
            if trunk then
                table.insert(trees, {tree = tree, trunk = trunk})
            end
        end
    end
    return trees
end

local function getAxe()
    local inv = LocalPlayer:FindFirstChild("Inventory")
    if not inv then return nil end
    return inv:FindFirstChild("Old Axe") or inv:FindFirstChildWhichIsA("Tool")
end

local function startTreeFarm()
    if treeFarmActive then return end
    treeFarmActive = true

    task.spawn(function()
        while treeFarmActive do
            local trees = getAllTrees()
            for _, t in ipairs(trees) do
                if not treeFarmActive then break end
                local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp and t.trunk then
                   
                    local treeCFrame = t.trunk.CFrame
                    local rightVector = treeCFrame.RightVector
                    local targetPosition = treeCFrame.Position + rightVector * 3
                    hrp.CFrame = CFrame.new(targetPosition)
                    task.wait(0.25)

                    local axe = getAxe()
                    if axe then
                        if axe.Parent == LocalPlayer.Backpack then
                            axe.Parent = char
                            task.wait(0.15)
                        end

                        while t.tree.Parent and treeFarmActive do
                            pcall(function() axe:Activate() end)
                            local args = {
                                t.tree,
                                axe,
                                "1_8264699301",
                                t.trunk.CFrame
                            }
                            pcall(function() ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("ToolDamageObject"):InvokeServer(unpack(args)) end)
                            task.wait(1)
                        end
                    end
                end
                task.wait(0.5)
            end
            task.wait(1)
        end
    end)
end

tab0.create_toggle({ 
    name = 'Auto Sapling',
    flag = 'killaura_enabled',
    section = 'left',
    enabled = false,

    callback = function(state)
        task.spawn(function()
            while task.wait(0.5) and state do
                for _, item in pairs(itemsFolder:GetChildren()) do
                    if item.Name == "Sapling" then
                        local randomX = getRandomCoord()
                        local randomZ = getRandomCoord()
                        local position = Vector3.new(randomX, 1, randomZ)

                        local args = {
                            item, 
                            position
                        }

                        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents"):WaitForChild("RequestPlantItem"):InvokeServer(unpack(args))
                    end
                end
            end
        end)
    end
})
local enabledBiofuelItems = {}

local dropdownOptions = table.clone(biofuelItems)
table.insert(dropdownOptions, 1, "All")

tab0.create_multidropdown({
    name = "Auto Biofuel",
    flag = "autobiofuel_items",
    section = "left",
    option = "None Selected",
    options = dropdownOptions,

    callback = function(selected)
        table.clear(enabledBiofuelItems)

        if table.find(selected, "All") then
            for _, item in ipairs(biofuelItems) do
                enabledBiofuelItems[item] = true
            end
        else
            for _, item in ipairs(selected) do
                enabledBiofuelItems[item] = true
            end
        end
    end
})


tab2.create_title({
    name = '== ABILITIY ==',
    section = 'left'
})
tab2.create_button({
    name = 'No fog',
    flag = 'Bringlog',

    section = 'left',
    enabled = false,

    callback = function(state: boolean)
    while task.wait() and state do
     local Lighting = game:GetService("Lighting")
        
        if value then
            Lighting:SetAttribute("FogStartOriginal", Lighting.FogStart)
            Lighting:SetAttribute("FogEndOriginal", Lighting.FogEnd)
            Lighting:SetAttribute("FogColorOriginal", Lighting.FogColor)
            
            Lighting.FogStart = 1e10
            Lighting.FogEnd = 1e10
            Lighting.FogColor = Color3.new(1, 1, 1)
        else
            local fogStart = Lighting:GetAttribute("FogStartOriginal") or 0
            local fogEnd = Lighting:GetAttribute("FogEndOriginal") or 100000
            local fogColor = Lighting:GetAttribute("FogColorOriginal") or Color3.new(1, 1, 1)

            Lighting.FogStart = fogStart
            Lighting.FogEnd = fogEnd
            Lighting.FogColor = fogColor
        end
    end
    end
})




local scanMapEnabled = false
local scanMapGUI = nil
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local scan_map = false
local scan_map_was_on = false


local function tp1()
    local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local hrp = character:WaitForChild("HumanoidRootPart")
    hrp.CFrame = CFrame.new(0.43132782, 15.77634621, -1.88620758, -0.270917892, 0.102997094, 0.957076371, 0.639657021, 0.762253821, 0.0990355015, -0.719334781, 0.639031112, -0.272391081)
end


local function startScanMap()
    scan_map = true
    scan_map_was_on = true
    task.spawn(function()
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart", 3)
        if not hrp then
            print("HumanoidRootPart not found")
            return
        end
        while scan_map do
            local targets = {}
           
         
            local map = workspace:FindFirstChild("Map")
            if map then
                local foliage = map:FindFirstChild("Foliage") or map:FindFirstChild("Landmarks")
                if foliage then
                    for _, obj in ipairs(foliage:GetChildren()) do
                        if obj.Name == "Small Tree" and obj:IsA("Model") then
                            local trunk = obj:FindFirstChild("Trunk") or obj.PrimaryPart
                            if trunk then
                                table.insert(targets, trunk)
                            end
                        end
                    end
                end
            end
   
            local characters = workspace:FindFirstChild("Characters")
            if characters then
                for _, entity in ipairs(characters:GetChildren()) do
                    if entity:IsA("Model") then
                        local entityNames = {"Wolf", "Alpha Wolf", "Bear", "Cultist", "Crossbow Cultist", "Alien", "Alien Elite", "Bunny", "Lost Child"}
                        for _, name in ipairs(entityNames) do
                            if entity.Name == name then
                                local hrp = entity:FindFirstChild("HumanoidRootPart")
                                if hrp then
                                    table.insert(targets, hrp)
                                end
                                break
                            end
                        end
                    end
                end
            end

            local items = workspace:FindFirstChild("Items")
            if items then
                for _, item in ipairs(items:GetChildren()) do
                    local structureNames = {"Stronghold", "Item Chest", "Chest", "Cabin", "Tent"}
                    for _, name in ipairs(structureNames) do
                        if item.Name == name then
                            local part = item:FindFirstChildWhichIsA("BasePart")
                            if part then
                                table.insert(targets, part)
                            end
                            break
                        end
                    end
                end
            end
      
            for _, target in ipairs(targets) do
                if not scan_map then break end
                if target and target.Parent then
                    local targetCFrame = target.CFrame
                    local rightVector = targetCFrame.RightVector
                    local targetPosition = targetCFrame.Position + rightVector * 69 + Vector3.new(0, 15, 69)
                   
                    hrp.CFrame = CFrame.new(targetPosition)
                   
                    task.wait(0.01)
                end
            end
            task.wait(0.25)
        end
    end)
end


local function stopScanMap()
    scan_map = false
    if scan_map_was_on then
        tp1()
        scan_map_was_on = false
    end
end


local function createScanMapGUI()
    if scanMapGUI and scanMapGUI.Parent then return scanMapGUI end
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ScanMapPopup"
    screenGui.Parent = game.Players.LocalPlayer.PlayerGui
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.ResetOnSpawn = false

    local FRAME_SIZE = Vector2.new(200, 180)
    local SHADOW_OFFSET = Vector2.new(15, 15)
    local SHADOW_SIZE = FRAME_SIZE + SHADOW_OFFSET
    local TOP_RIGHT_POSITION = UDim2.new(1, -210, 0, 10)
    local ACCENT_COLOR = Color3.fromRGB(88, 101, 242)


    local shadow = Instance.new("ImageLabel", screenGui)
    shadow.Name = "Shadow"
    shadow.AnchorPoint = Vector2.new(1, 0)
    shadow.Position = TOP_RIGHT_POSITION
    shadow.Size = UDim2.fromOffset(SHADOW_SIZE.X, SHADOW_SIZE.Y)
    shadow.BackgroundTransparency = 1.0
    shadow.ZIndex = 0
    shadow.Image = "rbxassetid://17290899982"

   
    local mainFrame = Instance.new("Frame", screenGui)
    mainFrame.Name = "MainFrame"
    mainFrame.Active = true
    mainFrame.AnchorPoint = Vector2.new(1, 0)
    mainFrame.Position = TOP_RIGHT_POSITION
    mainFrame.Size = UDim2.fromOffset(FRAME_SIZE.X, FRAME_SIZE.Y)
    mainFrame.BackgroundColor3 = Color3.fromRGB(19, 20, 24)
    mainFrame.BorderSizePixel = 0
    mainFrame.ClipsDescendants = true
    mainFrame.ZIndex = 1

    local mainCorner = Instance.new("UICorner", mainFrame)
    mainCorner.CornerRadius = UDim.new(0, 12)

 
    local closeButton = Instance.new("ImageButton", mainFrame)
    closeButton.Size = UDim2.new(0, 20, 0, 20)
    closeButton.Position = UDim2.new(1, -10, 0, 5)
    closeButton.AnchorPoint = Vector2.new(1, 0)
    closeButton.BackgroundColor3 = Color3.fromRGB(45, 45, 50)
    closeButton.BorderSizePixel = 0
    closeButton.AutoButtonColor = false
    closeButton.Image = "rbxassetid://133495621202705"
    closeButton.ImageColor3 = Color3.fromRGB(200, 200, 200)

    local closeCorner = Instance.new("UICorner", closeButton)
    closeCorner.CornerRadius = UDim.new(1, 10)

    local closeStroke = Instance.new("UIStroke", closeButton)
    closeStroke.Color = Color3.fromRGB(60, 60, 60)
    closeStroke.Thickness = 1
    closeStroke.Transparency = 0.5


    local title = Instance.new("TextLabel", mainFrame)
    title.Size = UDim2.new(1, -30, 0, 25)
    title.Position = UDim2.new(0, 10, 0, 5)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.Text = "Scan Map Controls"
    title.TextColor3 = ACCENT_COLOR
    title.TextSize = 16
    title.TextWrapped = true
    title.TextXAlignment = Enum.TextXAlignment.Left

    local titleStroke = Instance.new("UIStroke", title)
    titleStroke.Color = ACCENT_COLOR
    titleStroke.Thickness = 1
    titleStroke.Transparency = 0.8

  
    local statusLabel = Instance.new("TextLabel", mainFrame)
    statusLabel.Size = UDim2.new(1, -20, 0, 25)
    statusLabel.Position = UDim2.new(0.5, 0, 0.3, 0)
    statusLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.Text = "Scan Map: OFF"
    statusLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
    statusLabel.TextSize = 12
    statusLabel.TextWrapped = true
    statusLabel.TextXAlignment = Enum.TextXAlignment.Center

   
    local startButton = Instance.new("TextButton", mainFrame)
    startButton.Size = UDim2.new(1, -20, 0, 28)
    startButton.Position = UDim2.new(0.5, 0, 0.5, 0)
    startButton.AnchorPoint = Vector2.new(0.5, 0.5)
    startButton.Text = "START SCAN MAP"
    startButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    startButton.TextSize = 12
    startButton.Font = Enum.Font.Gotham
    startButton.BorderSizePixel = 0
    startButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    startButton.AutoButtonColor = false
    startButton.TextScaled = true

    local startCorner = Instance.new("UICorner", startButton)
    startCorner.CornerRadius = UDim.new(0, 8)

    local startStroke = Instance.new("UIStroke", startButton)
    startStroke.Color = Color3.fromRGB(0, 170, 0)
    startStroke.Thickness = 1
    startStroke.Transparency = 0.7


    local stopButton = Instance.new("TextButton", mainFrame)
    stopButton.Size = UDim2.new(1, -20, 0, 28)
    stopButton.Position = UDim2.new(0.5, 0, 0.7, 0)
    stopButton.AnchorPoint = Vector2.new(0.5, 0.5)
    stopButton.Text = "STOP SCAN MAP"
    stopButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    stopButton.TextSize = 12
    stopButton.Font = Enum.Font.Gotham
    stopButton.BorderSizePixel = 0
    stopButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    stopButton.AutoButtonColor = false
    stopButton.TextScaled = true

    local stopCorner = Instance.new("UICorner", stopButton)
    stopCorner.CornerRadius = UDim.new(0, 8)

    local stopStroke = Instance.new("UIStroke", stopButton)
    stopStroke.Color = Color3.fromRGB(170, 0, 0)
    stopStroke.Thickness = 1
    stopStroke.Transparency = 0.7

 
    task.spawn(function()
        local popInTime = 0.4
        local popInTweenInfo = TweenInfo.new(popInTime, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
        mainFrame.Size = UDim2.fromOffset(0, 0)
        shadow.Size = UDim2.fromOffset(0, 0)
        mainFrame.BackgroundTransparency = 1
        shadow.ImageTransparency = 1
        
        local frameTween = TweenService:Create(mainFrame, popInTweenInfo, {Size = UDim2.fromOffset(FRAME_SIZE.X, FRAME_SIZE.Y), BackgroundTransparency = 0})
        local shadowTween = TweenService:Create(shadow, popInTweenInfo, {Size = UDim2.fromOffset(SHADOW_SIZE.X, SHADOW_SIZE.Y), ImageTransparency = 0})
        frameTween:Play()
        shadowTween:Play()
    end)

   
    local isDragging = false
    local dragStart, frameStart
    mainFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = true
            dragStart = input.Position
            frameStart = mainFrame.Position
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) and isDragging then
            local delta = input.Position - dragStart
            mainFrame.Position = UDim2.new(frameStart.X.Scale, frameStart.X.Offset + delta.X, frameStart.Y.Scale, frameStart.Y.Offset + delta.Y)
            shadow.Position = mainFrame.Position
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = false
        end
    end)

   
    closeButton.MouseButton1Click:Connect(function()
        local closeTime = 0.3
        local closeTweenInfo = TweenInfo.new(closeTime, Enum.EasingStyle.Circular, Enum.EasingDirection.In)
        
        local frameTween = TweenService:Create(mainFrame, closeTweenInfo, {Size = UDim2.fromOffset(0, 0), BackgroundTransparency = 1})
        local shadowTween = TweenService:Create(shadow, closeTweenInfo, {Size = UDim2.fromOffset(0, 0), ImageTransparency = 1})
        frameTween:Play()
        shadowTween:Play()
        frameTween.Completed:Connect(function()
            if scan_map then stopScanMap() end
            screenGui:Destroy()
            scanMapGUI = nil
            scanMapEnabled = false 
        end)
    end)


    startButton.MouseButton1Click:Connect(function()
        if not scan_map then
            startScanMap()
            statusLabel.Text = "Scan Map: ON"
            statusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
        end
    end)


    stopButton.MouseButton1Click:Connect(function()
        if scan_map then
            stopScanMap()
            statusLabel.Text = "Scan Map: OFF"
            statusLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
        end
    end)

   
    local keybindConnection
    keybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.V then
            if scan_map then
                stopScanMap()
                statusLabel.Text = "Scan Map: OFF"
                statusLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
            else
                startScanMap()
                statusLabel.Text = "Scan Map: ON"
                statusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
            end
        end
    end)

  
    screenGui.AncestryChanged:Connect(function()
        if not screenGui.Parent then
            keybindConnection:Disconnect()
        end
    end)

    scanMapGUI = screenGui
    return screenGui
end

bringTab.create_toggle({
    name = 'Scan Map',
    flag = 'scan_map_toggle',
    section = 'left',
    enabled = false,
    callback = function(state)
        scanMapEnabled = state
        if state then
            createScanMapGUI()
        else
            if scanMapGUI and scanMapGUI.Parent then
                local closeTime = 0.3
                local closeTweenInfo = TweenInfo.new(closeTime, Enum.EasingStyle.Circular, Enum.EasingDirection.In)
                
                local mainFrame = scanMapGUI:FindFirstChild("MainFrame")
                local shadow = scanMapGUI:FindFirstChild("Shadow")
                if mainFrame and shadow then
                    local frameTween = TweenService:Create(mainFrame, closeTweenInfo, {Size = UDim2.fromOffset(0, 0), BackgroundTransparency = 1})
                    local shadowTween = TweenService:Create(shadow, closeTweenInfo, {Size = UDim2.fromOffset(0, 0), ImageTransparency = 1})
                    frameTween:Play()
                    shadowTween:Play()
                    frameTween.Completed:Connect(function()
                        if scan_map then stopScanMap() end
                        scanMapGUI:Destroy()
                        scanMapGUI = nil
                    end)
                end
            end
        end
    end
})

local function smoothPullToItem(startPos, endPos, duration)
    local player = game.Players.LocalPlayer
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local startTime = tick()
    local direction = (endPos.Position - startPos.Position).Unit

    
    local connection
    connection = game:GetService("RunService").Heartbeat:Connect(function()
        local elapsed = tick() - startTime
        if elapsed >= duration then
            connection:Disconnect()
            hrp.CFrame = endPos
            return
        end
        
        local progress = elapsed / duration
        
        
        local easedProgress = progress < 0.5 
            and 4 * progress * progress * progress 
            or 1 - math.pow(-2 * progress + 2, 3) / 2
        
        local currentPos = startPos.Position:lerp(endPos.Position, easedProgress)
        local lookDirection = endPos.Position - currentPos

        if lookDirection.Magnitude > 0 then
            hrp.CFrame = CFrame.lookAt(currentPos, currentPos + lookDirection.Unit)
        else
            hrp.CFrame = CFrame.new(currentPos)
        end
    end)
    
    wait(duration)
    if connection then connection:Disconnect() end
end


local function createItemPullEffect(itemPart, targetPos, duration)
    if not itemPart or not itemPart.Parent then return end
    
    local startPos = itemPart.Position
    local startTime = tick()
    
    local connection
    connection = game:GetService("RunService").Heartbeat:Connect(function()
        if not itemPart or not itemPart.Parent then 
            if connection then connection:Disconnect() end
            return 
        end
        
        local elapsed = tick() - startTime
        if elapsed >= duration then
            if connection then connection:Disconnect() end
            pcall(function()
                itemPart.CFrame = CFrame.new(targetPos)
                itemPart.Velocity = Vector3.new(0, 0, 0)
                itemPart.AngularVelocity = Vector3.new(0, 0, 0)
            end)
            return
        end
        
        local progress = elapsed / duration
        
       
        local easedProgress = 1 - math.pow(1 - progress, 4)
        
        local currentPos = startPos:lerp(targetPos, easedProgress)
        
        pcall(function()
            itemPart.CFrame = CFrame.new(currentPos)
            itemPart.Velocity = Vector3.new(0, 0, 0)
            itemPart.AngularVelocity = Vector3.new(0, 0, 0)
        end)
    end)
    
    wait(duration)
    if connection then connection:Disconnect() end
end


local collectedItems = {} 
local isCollecting = false
local originalPosition = nil

local function bypassBringSystem(items, stopFlag)
    if isCollecting then return end
    
    isCollecting = true
    local player = game.Players.LocalPlayer
    
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then 
        isCollecting = false
        return 
    end
    
    local hrp = player.Character.HumanoidRootPart
    originalPosition = hrp.CFrame

   
    local allItems = {}
    
    for _, itemName in ipairs(items) do
       
        for _, descendant in ipairs(workspace:GetDescendants()) do
            if descendant.Name == itemName and (descendant:IsA("BasePart") or descendant:IsA("Model")) then
                local itemPart = descendant:IsA("Model") and 
                    (descendant.PrimaryPart or descendant:FindFirstChildWhichIsA("BasePart")) or descendant
                
                if itemPart and itemPart.Parent ~= player.Character then
                    table.insert(allItems, {
                        item = descendant,
                        part = itemPart,
                        originalCFrame = itemPart.CFrame,
                        type = "item"
                    })
                end
            end
        end
        
        
        local charactersFolder = workspace:FindFirstChild("Characters")
        if charactersFolder and itemName:find("Child") then
            for _, child in ipairs(charactersFolder:GetChildren()) do
                if child.Name == itemName and child:IsA("Model") then
                    local humanoidRootPart = child:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart and humanoidRootPart.Parent ~= player.Character then
                        table.insert(allItems, {
                            item = child,
                            part = humanoidRootPart,
                            originalCFrame = humanoidRootPart.CFrame,
                            type = "child"
                        })
                    end
                end
            end
        end
    end

    
    for _, itemData in ipairs(allItems) do
        if stopFlag and not stopFlag() then break end
        
        local item = itemData.item
        local itemPart = itemData.part
        
        if itemPart and itemPart.Parent then
            
            if (itemPart.Position - itemData.originalCFrame.Position).Magnitude > 10 then
                continue
            end

           
            if itemData.type == "child" then
                
                local childHumanoid = item:FindFirstChild("Humanoid")
                if childHumanoid then
                    
                    childHumanoid:SetStateEnabled(Enum.HumanoidStateType.Running, false)
                    childHumanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
                end
            end

        
            local itemPos = itemPart.CFrame + Vector3.new(0, 3, 0) 
            smoothPullToItem(hrp.CFrame, itemPos, 0.8) 
            
          
            local playerPos = hrp.Position + Vector3.new(0, -1, 0)
            createItemPullEffect(itemPart, playerPos, 0.5) 
            
            
            local keepAttached = true
            local attachmentConnection
            attachmentConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not keepAttached or not itemPart or not itemPart.Parent or not hrp or not hrp.Parent then
                    if attachmentConnection then attachmentConnection:Disconnect() end
                    return
                end
                
                pcall(function()
                    local offset = Vector3.new(
                        math.sin(tick() * 3) * 0.3, 
                        -1 + math.cos(tick() * 4) * 0.1,
                        math.cos(tick() * 3) * 0.3
                    )
                    itemPart.CFrame = CFrame.new(hrp.Position + offset)
                    itemPart.Velocity = Vector3.new(0, 0, 0)
                    itemPart.AngularVelocity = Vector3.new(0, 0, 0)
                end)
            end)
            
           
            smoothPullToItem(hrp.CFrame, originalPosition, 0.7)
            
            
            keepAttached = false
            if attachmentConnection then attachmentConnection:Disconnect() end
            
            pcall(function()
                local landingPos = originalPosition.Position + Vector3.new(
                    math.random(-3, 3), 
                    1.5, 
                    math.random(-3, 3)
                )
                
                createItemPullEffect(itemPart, landingPos, 0.3) 
            end)
            
            
            if itemData.type == "child" then
                local childHumanoid = item:FindFirstChild("Humanoid")
                if childHumanoid then
                    childHumanoid:SetStateEnabled(Enum.HumanoidStateType.Running, true)
                    childHumanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
                end
            end
        end
        
        wait(0.3) 
    end
    
    
    if originalPosition then
        hrp.CFrame = originalPosition
    end
    
    isCollecting = false
end


local function clearCollectedMemory()
    collectedItems = {}
    print("Collected items memory cleared")
end

local selectedItems = {}
local bringEnabled = false
local itemsFolder = workspace:WaitForChild("Items")
local characters = workspace:WaitForChild("Characters")

local function getUniqueItems()
    local uniqueItems = {}
    local addedNames = {}
    for _, itm in pairs(itemsFolder:GetChildren()) do
        if typeof(itm.Name) == "string" and not addedNames[itm.Name] then
            table.insert(uniqueItems, itm.Name)
            addedNames[itm.Name] = true
        end
    end
    table.sort(uniqueItems)
    return uniqueItems
end

local debounce = false
local function updateItemsDropdown()
    if debounce then return end
    debounce = true

    task.delay(0.1, function()
        local uniqueItems = getUniqueItems()
        itemsDropdown.options = uniqueItems
        itemsDropdown:update()
        debounce = false
    end)
end
bringTab.create_title({
    name = '== ITEM BRINGER ==',
    section = 'left'
})

local itemsDropdown = bringTab.create_multidropdown({
    name = 'Select items',
    flag = 'select_items',
    section = 'left',
    option = 'Select Items',
    options = getUniqueItems(),
    placeholders = {},
    multi = true,
    callback = function(selected)
        selectedItems = {}
        for _, name in ipairs(selected) do
            selectedItems[name] = true
        end
    end
})

local function setupItemsAutoRefresh()
    local function refreshItemsDropdown()
        local uniqueItems = getUniqueItems()
        itemsDropdown:SetOption(uniqueItems)
    end
    
    itemsFolder.ChildAdded:Connect(refreshItemsDropdown)
    itemsFolder.ChildRemoved:Connect(refreshItemsDropdown)
end

setupItemsAutoRefresh()

bringTab.create_toggle({
    name = 'Bring Selected Items',
    flag = 'bring_items_toggle',
    section = 'left',
    enabled = false,
    callback = function(state)
        bringEnabled = state
        if not state then
            clearCollectedMemory()
        end
        if state then
            coroutine.wrap(function()
                while bringEnabled do
                    local itemsToBring = {}
                    for name, sel in pairs(selectedItems) do
                        if sel then table.insert(itemsToBring, name) end
                    end
                    if #itemsToBring > 0 then
                        bypassBringSystem(itemsToBring, function() return bringEnabled end)
                    end
                    wait(1)
                end
            end)()
        end
    end
})

local selectedChildren = {}
local childBringEnabled = false

local function getUniqueKids()
    local uniqueKids = {}
    for _, kid in pairs(characters:GetChildren()) do
        if kid.Name:find("Child") then
            if not table.find(uniqueKids, kid.Name) then
                table.insert(uniqueKids, kid.Name)
            end
        end
    end
    if #uniqueKids == 0 then
        table.insert(uniqueKids, "No children spawned yet")
    end
    table.sort(uniqueKids)
    return uniqueKids
end

local debounce2 = false
local function updateKidsDropdown()
    if debounce2 then return end
    debounce2 = true

    task.delay(0.1, function()
        local uniqueKids = getUniqueKids()
        kidsDropdown.options = uniqueKids
        kidsDropdown:update()
        debounce2 = false
    end)
end
bringTab.create_title({
    name = '== CHILD SUPPORT ==',
    section = 'left'
})
local kidsDropdown = bringTab.create_multidropdown({
    name = 'Select Children to Bring',
    flag = 'select_children',
    section = 'left',
    option = 'Select Children',
    options = getUniqueKids(),
    multi = true,
    callback = function(selected)
        selectedChildren = {}
        for _, name in ipairs(selected) do
            if name ~= "No children spawned yet" then
                selectedChildren[name] = true
            end
        end
    end
})

kidsDropdown.update = kidsDropdown.update or function(self) end 

characters.ChildAdded:Connect(updateKidsDropdown)
characters.ChildRemoved:Connect(updateKidsDropdown)

bringTab.create_toggle({
    name = 'Bring Selected Children',
    flag = 'bring_children_toggle',
    section = 'left',
    enabled = false,
    callback = function(state)
        childBringEnabled = state
        if not state then
            clearCollectedMemory()
        end
        if state then
            coroutine.wrap(function()
                while childBringEnabled do
                    local itemsToBring = {}
                    for name, sel in pairs(selectedChildren) do
                        if sel then table.insert(itemsToBring, name) end
                    end
                    if #itemsToBring > 0 then
                        bypassBringSystem(itemsToBring, function() return childBringEnabled end)
                    end
                    wait(1)
                end
            end)()
        end
    end
})

local localPlayer = Players.LocalPlayer
local characterFolder = Workspace:WaitForChild("Characters")

local selectedNames = {}
local savedPositions = {}
local characterDropdown
local characterBringEnabled = false
local characterBringConnection

local function getSortedUniqueCharacterNames()
    local found = {}
    for _, char in ipairs(characterFolder:GetChildren()) do
        if char:IsA("Model") and char:GetPivot() then
            found[char.Name] = true
        end
    end
    local list = {"All"}
    for name in pairs(found) do
        table.insert(list, name)
    end
    table.sort(list, function(a,b)
        if a == "All" then return true
        elseif b == "All" then return false
        else return a < b
        end
    end)
    return list
end

local function disableCollision(model)
    for _, part in ipairs(model:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end
bringTab.create_title({
    name = '== ENEMY BRINGER ==',
    section = 'left'
})
characterDropdown = bringTab.create_multidropdown({
    name = 'Select entity to bring',
    flag = 'character_tp_dropdown',
    section = 'left',
    option = 'Select Characters',
    options = getSortedUniqueCharacterNames(),

    callback = function(selected)
        selectedNames = selected
    end
})

function characterDropdown:Refresh()
    self.options = getSortedUniqueCharacterNames()
    self:update()
end

characterFolder.ChildAdded:Connect(function()
    task.wait(0.1)
    characterDropdown:Refresh()
end)

characterFolder.ChildRemoved:Connect(function()
    task.wait(0.1)
    characterDropdown:Refresh()
end)

bringTab.create_toggle({
    name = 'Bring Selected Entity',
    flag = 'bring_character_toggle',
    section = 'left',
    enabled = false,
    callback = function(state)
        characterBringEnabled = state
        if state then
            characterBringConnection = RunService.RenderStepped:Connect(function()
                local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end

                local allSelected = table.find(selectedNames, "All") ~= nil

                for _, char in ipairs(characterFolder:GetChildren()) do
                    if char:IsA("Model") and char:GetPivot() then
                        local name = char.Name
                        local isSelected = allSelected or table.find(selectedNames, name) ~= nil
                        local pivot = char:GetPivot()

                        if isSelected then
                            if not savedPositions[char] then
                                savedPositions[char] = pivot
                            end
                            char:PivotTo(CFrame.new(hrp.Position + Vector3.new(0,4,0)))
                            disableCollision(char)
                        else
                            if savedPositions[char] then
                                char:PivotTo(savedPositions[char])
                                savedPositions[char] = nil
                            end
                        end
                    end
                end
            end)
        else
            if characterBringConnection then
                characterBringConnection:Disconnect()
                characterBringConnection = nil
            end
        end
    end
})


local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")


local function createSafezoneGUI(originalPosition)
    local G2L = {}
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "SafeZonePopup"
    screenGui.Parent = game.Players.LocalPlayer.PlayerGui
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.ResetOnSpawn = false

    local FRAME_SIZE = Vector2.new(180, 120)
    local SHADOW_OFFSET = Vector2.new(15, 15)
    local SHADOW_SIZE = FRAME_SIZE + SHADOW_OFFSET
    local TOP_RIGHT_POSITION = UDim2.new(1, -190, 0, 10)
    local ACCENT_COLOR = Color3.fromRGB(88, 101, 242)

 
    G2L["s"] = Instance.new("ImageLabel", screenGui)
    G2L["s"]["Name"] = "Shadow"
    G2L["s"]["AnchorPoint"] = Vector2.new(1, 0)
    G2L["s"]["Position"] = TOP_RIGHT_POSITION
    G2L["s"]["Size"] = UDim2.fromOffset(SHADOW_SIZE.X, SHADOW_SIZE.Y)
    G2L["s"]["BackgroundTransparency"] = 1.0
    G2L["s"]["ZIndex"] = 0
    G2L["s"]["Image"] = "rbxassetid://17290899982"

 
    G2L["2"] = Instance.new("Frame", screenGui)
    G2L["2"]["Name"] = "MainFrame"
    G2L["2"]["Active"] = true
    G2L["2"]["AnchorPoint"] = Vector2.new(1, 0)
    G2L["2"]["Position"] = TOP_RIGHT_POSITION
    G2L["2"]["Size"] = UDim2.fromOffset(FRAME_SIZE.X, FRAME_SIZE.Y)
    G2L["2"]["BackgroundColor3"] = Color3.fromRGB(19, 20, 24)
    G2L["2"]["BorderSizePixel"] = 0
    G2L["2"]["ClipsDescendants"] = true
    G2L["2"]["ZIndex"] = 1

    G2L["7"] = Instance.new("UICorner", G2L["2"])
    G2L["7"]["CornerRadius"] = UDim.new(0, 12)

  
    G2L["CloseButton"] = Instance.new("ImageButton", G2L["2"])
    G2L["CloseButton"]["Size"] = UDim2.new(0, 20, 0, 20)
    G2L["CloseButton"]["Position"] = UDim2.new(1, -10, 0, 5)
    G2L["CloseButton"]["AnchorPoint"] = Vector2.new(1, 0)
    G2L["CloseButton"]["BackgroundColor3"] = Color3.fromRGB(45, 45, 50)
    G2L["CloseButton"]["BorderSizePixel"] = 0
    G2L["CloseButton"]["AutoButtonColor"] = false
    G2L["CloseButton"]["Image"] = "rbxassetid://133495621202705"
    G2L["CloseButton"]["ImageColor3"] = Color3.fromRGB(200, 200, 200)

    local CloseCorner = Instance.new("UICorner", G2L["CloseButton"])
    CloseCorner["CornerRadius"] = UDim.new(1, 10)

    local CloseStroke = Instance.new("UIStroke", G2L["CloseButton"])
    CloseStroke["Color"] = Color3.fromRGB(60, 60, 60)
    CloseStroke["Thickness"] = 1
    CloseStroke["Transparency"] = 0.5


    G2L["Title"] = Instance.new("TextLabel", G2L["2"])
    G2L["Title"]["Size"] = UDim2.new(1, -30, 0, 25)
    G2L["Title"]["Position"] = UDim2.new(0, 10, 0, 5)
    G2L["Title"]["BackgroundTransparency"] = 1
    G2L["Title"]["FontFace"] = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.Bold)
    G2L["Title"]["Text"] = "Teleport Assist"
    G2L["Title"]["TextColor3"] = ACCENT_COLOR
    G2L["Title"]["TextSize"] = 16
    G2L["Title"]["TextWrapped"] = true
    G2L["Title"]["TextXAlignment"] = Enum.TextXAlignment.Left

    local TitleStroke = Instance.new("UIStroke", G2L["Title"])
    TitleStroke["Color"] = ACCENT_COLOR
    TitleStroke["Thickness"] = 1
    TitleStroke["Transparency"] = 0.8


    G2L["SafeButton"] = Instance.new("TextButton", G2L["2"])
    G2L["SafeButton"]["Size"] = UDim2.new(1, -20, 0, 28)
    G2L["SafeButton"]["Position"] = UDim2.new(0.5, 0, 0.4, 0)
    G2L["SafeButton"]["AnchorPoint"] = Vector2.new(0.5, 0.5)
    G2L["SafeButton"]["Text"] = "SafeZone"
    G2L["SafeButton"]["TextColor3"] = Color3.fromRGB(255, 255, 255)
    G2L["SafeButton"]["TextSize"] = 12
    G2L["SafeButton"]["FontFace"] = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
    G2L["SafeButton"]["BorderSizePixel"] = 0
    G2L["SafeButton"]["BackgroundColor3"] = Color3.fromRGB(27, 28, 33)
    G2L["SafeButton"]["AutoButtonColor"] = false
    G2L["SafeButton"]["TextScaled"] = true

    G2L["SafeCorner"] = Instance.new("UICorner", G2L["SafeButton"])
    G2L["SafeCorner"]["CornerRadius"] = UDim.new(0, 8)

    local SafeStroke = Instance.new("UIStroke", G2L["SafeButton"])
    SafeStroke["Color"] = ACCENT_COLOR
    SafeStroke["Thickness"] = 1
    SafeStroke["Transparency"] = 0.7

  
    G2L["ReturnButton"] = Instance.new("TextButton", G2L["2"])
    G2L["ReturnButton"]["Size"] = UDim2.new(1, -20, 0, 28)
    G2L["ReturnButton"]["Position"] = UDim2.new(0.5, 0, 0.75, 0)
    G2L["ReturnButton"]["AnchorPoint"] = Vector2.new(0.5, 0.5)
    G2L["ReturnButton"]["Text"] = "Return"
    G2L["ReturnButton"]["TextColor3"] = Color3.fromRGB(255, 255, 255)
    G2L["ReturnButton"]["TextSize"] = 12
    G2L["ReturnButton"]["FontFace"] = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
    G2L["ReturnButton"]["BorderSizePixel"] = 0
    G2L["ReturnButton"]["BackgroundColor3"] = Color3.fromRGB(35, 35, 35)
    G2L["ReturnButton"]["AutoButtonColor"] = false
    G2L["ReturnButton"]["TextScaled"] = true

    G2L["ReturnCorner"] = Instance.new("UICorner", G2L["ReturnButton"])
    G2L["ReturnCorner"]["CornerRadius"] = UDim.new(0, 8)

    local ReturnStroke = Instance.new("UIStroke", G2L["ReturnButton"])
    ReturnStroke["Color"] = Color3.fromRGB(200, 80, 80)
    ReturnStroke["Thickness"] = 1
    ReturnStroke["Transparency"] = 0.7

  
    task.spawn(function()
        local popInTime = 0.4
        local popInTweenInfo = TweenInfo.new(popInTime, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
        G2L["2"].Size, G2L["s"].Size = UDim2.fromOffset(0,0), UDim2.fromOffset(0,0)
        G2L["2"].BackgroundTransparency, G2L["s"].ImageTransparency = 1, 1
        
        local frameTween = TweenService:Create(G2L["2"], popInTweenInfo, { Size = UDim2.fromOffset(FRAME_SIZE.X, FRAME_SIZE.Y), BackgroundTransparency = 0 })
        local shadowTween = TweenService:Create(G2L["s"], popInTweenInfo, { Size = UDim2.fromOffset(SHADOW_SIZE.X, SHADOW_SIZE.Y), ImageTransparency = 0 })
        frameTween:Play()
        shadowTween:Play()
    end)


    local isDragging = false
    local dragStart, frameStart
    
    G2L["2"].InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging, dragStart, frameStart = true, input.Position, G2L["2"].Position
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) and isDragging then
            local delta = input.Position - dragStart
            G2L["2"].Position = UDim2.new(frameStart.X.Scale, frameStart.X.Offset + delta.X, frameStart.Y.Scale, frameStart.Y.Offset + delta.Y)
            G2L["s"].Position = G2L["2"].Position
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = false
        end
    end)


    G2L["CloseButton"].MouseButton1Click:Connect(function()
        local closeTime = 0.3
        local closeTweenInfo = TweenInfo.new(closeTime, Enum.EasingStyle.Circular, Enum.EasingDirection.In)
        
        local frameTween = TweenService:Create(G2L["2"], closeTweenInfo, { Size = UDim2.fromOffset(0,0), BackgroundTransparency = 1 })
        local shadowTween = TweenService:Create(G2L["s"], closeTweenInfo, { Size = UDim2.fromOffset(0,0), ImageTransparency = 1 })
        frameTween:Play()
        shadowTween:Play()
        frameTween.Completed:Connect(function() 
            screenGui:Destroy() 
            
       
            local baseplate = workspace:FindFirstChild("TeleportSafezoneBaseplate")
            if baseplate then
                baseplate:Destroy()
            end
        end)
    end)


    G2L["SafeButton"].MouseButton1Click:Connect(function()
 
        local function teleportToTarget(cf, duration)
            local char = game.Players.LocalPlayer.Character
            if not char then return end
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            if duration and duration > 0 then
                local ts = TweenService
                local info = TweenInfo.new(duration, Enum.EasingStyle.Linear)
                local goal = { CFrame = cf }
                local tween = ts:Create(hrp, info, goal)
                tween:Play()
            else
                hrp.CFrame = cf
            end
        end

        local function stringToCFrame(str)
            local x, y, z = str:match("([^,]+),%s*([^,]+),%s*([^,]+)")
            return CFrame.new(tonumber(x), tonumber(y), tonumber(z))
        end

        local storyCoords = {
            { "[safezone] safe zone", "0, 140, -0" }
        }

        for _, entry in ipairs(storyCoords) do
            local name, coord = entry[1], entry[2]
            if name:lower():find("safezone") then
                teleportToTarget(stringToCFrame(coord), 0.5)
                break
            end
        end
    end)

   
    G2L["ReturnButton"].MouseButton1Click:Connect(function()

        local character = game.Players.LocalPlayer.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            character.HumanoidRootPart.CFrame = originalPosition
        end
        
   
        G2L["CloseButton"].MouseButton1Click:Fire()
    end)

    return screenGui
end

tab.create_title({
    name = '== TELEPORTS ==',
    section = 'left'
})

local function createClickTeleportGUI()
    local G2L = {}
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ClickTeleportPopup"
    screenGui.Parent = game.Players.LocalPlayer.PlayerGui
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.ResetOnSpawn = false

    local FRAME_SIZE = Vector2.new(180, 100)
    local SHADOW_OFFSET = Vector2.new(15, 15)
    local SHADOW_SIZE = FRAME_SIZE + SHADOW_OFFSET
    local TOP_RIGHT_POSITION = UDim2.new(1, -190, 0, 140)
    local ACCENT_COLOR = Color3.fromRGB(88, 101, 242)


    G2L["s"] = Instance.new("ImageLabel", screenGui)
    G2L["s"]["Name"] = "Shadow"
    G2L["s"]["AnchorPoint"] = Vector2.new(1, 0)
    G2L["s"]["Position"] = TOP_RIGHT_POSITION
    G2L["s"]["Size"] = UDim2.fromOffset(SHADOW_SIZE.X, SHADOW_SIZE.Y)
    G2L["s"]["BackgroundTransparency"] = 1.0
    G2L["s"]["ZIndex"] = 0
    G2L["s"]["Image"] = "rbxassetid://17290899982"


    G2L["2"] = Instance.new("Frame", screenGui)
    G2L["2"]["Name"] = "MainFrame"
    G2L["2"]["Active"] = true
    G2L["2"]["AnchorPoint"] = Vector2.new(1, 0)
    G2L["2"]["Position"] = TOP_RIGHT_POSITION
    G2L["2"]["Size"] = UDim2.fromOffset(FRAME_SIZE.X, FRAME_SIZE.Y)
    G2L["2"]["BackgroundColor3"] = Color3.fromRGB(19, 20, 24)
    G2L["2"]["BorderSizePixel"] = 0
    G2L["2"]["ClipsDescendants"] = true
    G2L["2"]["ZIndex"] = 1

    G2L["7"] = Instance.new("UICorner", G2L["2"])
    G2L["7"]["CornerRadius"] = UDim.new(0, 12)

   
    G2L["CloseButton"] = Instance.new("ImageButton", G2L["2"])
    G2L["CloseButton"]["Size"] = UDim2.new(0, 20, 0, 20)
    G2L["CloseButton"]["Position"] = UDim2.new(1, -10, 0, 5)
    G2L["CloseButton"]["AnchorPoint"] = Vector2.new(1, 0)
    G2L["CloseButton"]["BackgroundColor3"] = Color3.fromRGB(45, 45, 50)
    G2L["CloseButton"]["BorderSizePixel"] = 0
    G2L["CloseButton"]["AutoButtonColor"] = false
    G2L["CloseButton"]["Image"] = "rbxassetid://133495621202705"
    G2L["CloseButton"]["ImageColor3"] = Color3.fromRGB(200, 200, 200)

    local CloseCorner = Instance.new("UICorner", G2L["CloseButton"])
    CloseCorner["CornerRadius"] = UDim.new(1, 10)

    local CloseStroke = Instance.new("UIStroke", G2L["CloseButton"])
    CloseStroke["Color"] = Color3.fromRGB(60, 60, 60)
    CloseStroke["Thickness"] = 1
    CloseStroke["Transparency"] = 0.5


    G2L["Title"] = Instance.new("TextLabel", G2L["2"])
    G2L["Title"]["Size"] = UDim2.new(1, -30, 0, 25)
    G2L["Title"]["Position"] = UDim2.new(0, 10, 0, 5)
    G2L["Title"]["BackgroundTransparency"] = 1
    G2L["Title"]["FontFace"] = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.Bold)
    G2L["Title"]["Text"] = "Click Teleport"
    G2L["Title"]["TextColor3"] = ACCENT_COLOR
    G2L["Title"]["TextSize"] = 16
    G2L["Title"]["TextWrapped"] = true
    G2L["Title"]["TextXAlignment"] = Enum.TextXAlignment.Left

    local TitleStroke = Instance.new("UIStroke", G2L["Title"])
    TitleStroke["Color"] = ACCENT_COLOR
    TitleStroke["Thickness"] = 1
    TitleStroke["Transparency"] = 0.8


    G2L["ToggleButton"] = Instance.new("TextButton", G2L["2"])
    G2L["ToggleButton"]["Size"] = UDim2.new(1, -20, 0, 28)
    G2L["ToggleButton"]["Position"] = UDim2.new(0.5, 0, 0.6, 0)
    G2L["ToggleButton"]["AnchorPoint"] = Vector2.new(0.5, 0.5)
    G2L["ToggleButton"]["Text"] = "Click TP: OFF"
    G2L["ToggleButton"]["TextColor3"] = Color3.fromRGB(255, 255, 255)
    G2L["ToggleButton"]["TextSize"] = 12
    G2L["ToggleButton"]["FontFace"] = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
    G2L["ToggleButton"]["BorderSizePixel"] = 0
    G2L["ToggleButton"]["BackgroundColor3"] = Color3.fromRGB(35, 35, 35)
    G2L["ToggleButton"]["AutoButtonColor"] = false
    G2L["ToggleButton"]["TextScaled"] = true

    G2L["ToggleCorner"] = Instance.new("UICorner", G2L["ToggleButton"])
    G2L["ToggleCorner"]["CornerRadius"] = UDim.new(0, 8)

    local ToggleStroke = Instance.new("UIStroke", G2L["ToggleButton"])
    ToggleStroke["Color"] = Color3.fromRGB(200, 80, 80)
    ToggleStroke["Thickness"] = 1
    ToggleStroke["Transparency"] = 0.7

   
    task.spawn(function()
        local popInTime = 0.4
        local popInTweenInfo = TweenInfo.new(popInTime, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
        G2L["2"].Size, G2L["s"].Size = UDim2.fromOffset(0,0), UDim2.fromOffset(0,0)
        G2L["2"].BackgroundTransparency, G2L["s"].ImageTransparency = 1, 1
        
        local frameTween = TweenService:Create(G2L["2"], popInTweenInfo, { Size = UDim2.fromOffset(FRAME_SIZE.X, FRAME_SIZE.Y), BackgroundTransparency = 0 })
        local shadowTween = TweenService:Create(G2L["s"], popInTweenInfo, { Size = UDim2.fromOffset(SHADOW_SIZE.X, SHADOW_SIZE.Y), ImageTransparency = 0 })
        frameTween:Play()
        shadowTween:Play()
    end)

    
    local isDragging = false
    local dragStart, frameStart
    
    G2L["2"].InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging, dragStart, frameStart = true, input.Position, G2L["2"].Position
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) and isDragging then
            local delta = input.Position - dragStart
            G2L["2"].Position = UDim2.new(frameStart.X.Scale, frameStart.X.Offset + delta.X, frameStart.Y.Scale, frameStart.Y.Offset + delta.Y)
            G2L["s"].Position = G2L["2"].Position
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = false
        end
    end)

 
    G2L["CloseButton"].MouseButton1Click:Connect(function()
        local closeTime = 0.3
        local closeTweenInfo = TweenInfo.new(closeTime, Enum.EasingStyle.Circular, Enum.EasingDirection.In)
        
        local frameTween = TweenService:Create(G2L["2"], closeTweenInfo, { Size = UDim2.fromOffset(0,0), BackgroundTransparency = 1 })
        local shadowTween = TweenService:Create(G2L["s"], closeTweenInfo, { Size = UDim2.fromOffset(0,0), ImageTransparency = 1 })
        frameTween:Play()
        shadowTween:Play()
        frameTween.Completed:Connect(function() 
            screenGui:Destroy() 
        end)
    end)


    local clickTeleportEnabled = false
    local clickTeleportConnection = nil
    
    G2L["ToggleButton"].MouseButton1Click:Connect(function()
        clickTeleportEnabled = not clickTeleportEnabled
        
        if clickTeleportEnabled then
            G2L["ToggleButton"].Text = "Click TP: ON"
            ToggleStroke.Color = Color3.fromRGB(80, 200, 80)
            

            clickTeleportConnection = LocalPlayer:GetMouse().Button1Down:Connect(function()
                pcall(function()
                    local character = LocalPlayer.Character
                    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                    local mouse = LocalPlayer:GetMouse()
                    if rootPart and mouse.Hit then
                        rootPart.CFrame = CFrame.new(mouse.Hit.Position + Vector3.new(0, 5, 0))
                    end
                end)
            end)
        else
            G2L["ToggleButton"].Text = "Click TP: OFF"
            ToggleStroke.Color = Color3.fromRGB(200, 80, 80)
            
   
            if clickTeleportConnection then
                clickTeleportConnection:Disconnect()
                clickTeleportConnection = nil
            end
        end
    end)

    return screenGui
end


tab.create_button({
    name = 'Click Teleport Controls',
    flag = 'click_teleport_controls',
    section = 'left',
    callback = function()
        createClickTeleportGUI()
    end
})

tab.create_toggle({
    name = 'Teleport To SafeZone',
    flag = 'teleport_safezone',
    section = 'left',
    enabled = false,
    callback = function(state)
        if state then
 
            local character = game.Players.LocalPlayer.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then return end
            local originalPosition = character.HumanoidRootPart.CFrame
            
    
            local baseplate = workspace:FindFirstChild("TeleportSafezoneBaseplate")
            if not baseplate then
                baseplate = Instance.new("Part")
                baseplate.Name = "TeleportSafezoneBaseplate"
                baseplate.Size = Vector3.new(100, 5, 100)
                baseplate.Position = Vector3.new(0, 140, 0)
                baseplate.Anchored = true
                baseplate.CanCollide = true
                baseplate.Transparency = 0.5
                baseplate.Color = Color3.fromRGB(100, 100, 255)
                baseplate.Parent = workspace
            end
            
    
            local function teleportToTarget(cf, duration)
                local char = game.Players.LocalPlayer.Character
                if not char then return end
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if not hrp then return end

                if duration and duration > 0 then
                    local ts = TweenService
                    local info = TweenInfo.new(duration, Enum.EasingStyle.Linear)
                    local goal = { CFrame = cf }
                    local tween = ts:Create(hrp, info, goal)
                    tween:Play()
                else
                    hrp.CFrame = cf
                end
            end

            local function stringToCFrame(str)
                local x, y, z = str:match("([^,]+),%s*([^,]+),%s*([^,]+)")
                return CFrame.new(tonumber(x), tonumber(y), tonumber(z))
            end

            local storyCoords = {
                { "[safezone] safe zone", "0, 140, -0" }
            }

  
            for _, entry in ipairs(storyCoords) do
                local name, coord = entry[1], entry[2]
                if name:lower():find("safezone") then
                    teleportToTarget(stringToCFrame(coord), 0.5)
                    break
                end
            end
            

            wait(1)
            createSafezoneGUI(originalPosition)
        else
           
            local gui = game.Players.LocalPlayer.PlayerGui:FindFirstChild("SafeZonePopup")
            if gui then
                gui:Destroy()
            end
            
            local baseplate = workspace:FindFirstChild("TeleportSafezoneBaseplate")
            if baseplate then
                baseplate:Destroy()
            end
        end
    end
})


tab.create_button({
    name = 'Teleport To Camp',
    flag = 'Bringlog',

    section = 'left',
    enabled = false,

    callback = function(state: boolean)
      local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HRP = Character:WaitForChild("HumanoidRootPart")

HRP.CFrame = CFrame.new(
    13.287363052368164, 3.999999761581421, 0.36212217807769775,
    0.6022269129753113, -2.275036159460342e-08, 0.7983249425888062,
    6.430457055728311e-09, 1, 2.364672191390582e-08,
    -0.7983249425888062, -9.1070981866892e-09, 0.6022269129753113
)
    end
})




local function getMobs()
    local mobs = {}
    local mobNames = {}
    local index = 1
    for _, character in ipairs(Workspace:WaitForChild("Characters"):GetChildren()) do
        if character.Name:match("^Lost Child") and character:GetAttribute("Lost") == true then
            table.insert(mobs, character)
            table.insert(mobNames, character.Name)
            index = index + 1
        end
    end
    if #mobNames == 0 then
        table.insert(mobNames, "No children spawned yet")
    end
    table.sort(mobNames)
    return mobs, mobNames
end

local currentMobs, currentMobNames = getMobs()
local selectedMob = currentMobNames[1] or nil

tab.create_title({
    name = '== CHILDREN (Max Fire lvl Required) ==',
    section = 'left'
})

local debounceChild = false
local function updateChildDropdown()
    if debounceChild then return end
    debounceChild = true

    task.delay(0.1, function()
        currentMobs, currentMobNames = getMobs()
        childDropdown.options = currentMobNames
        childDropdown:update()
        debounceChild = false
    end)
end

local childDropdown = tab.create_multidropdown({
    name = 'Select Child to Teleport',
    flag = 'select_child_tp',
    section = 'left',
    option = 'Select Child',
    options = currentMobNames,
    multi = false,  
    callback = function(selected)
        if #selected > 0 then
            selectedMob = selected[1] 
        else
            selectedMob = nil
        end
    end
})

childDropdown.update = childDropdown.update or function(self) end


local charactersFolder = Workspace:WaitForChild("Characters")
charactersFolder.ChildAdded:Connect(updateChildDropdown)
charactersFolder.ChildRemoved:Connect(updateChildDropdown)

tab.create_button({
    name = 'Refresh Child List',
    flag = 'refresh_child_list',
    section = 'left',
    callback = function()
        updateChildDropdown()
        print("Child list refreshed!")
    end
})

tab.create_button({
    name = 'Teleport to Selected Child',
    flag = 'tp_to_child',
    section = 'left',
    callback = function()
        if selectedMob and selectedMob ~= "No children spawned yet" and currentMobs then
            local childIndex = 1
            for i, name in ipairs(currentMobNames) do
                if name == selectedMob then
                    childIndex = i
                    break
                end
            end
            local targetChild = currentMobs[childIndex]
            if targetChild then
                local part = targetChild.PrimaryPart or targetChild:FindFirstChildWhichIsA("BasePart")
                if part and LocalPlayer.Character then
                    local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.CFrame = part.CFrame + Vector3.new(0, 5, 0)
                        print("Teleported to child: " .. selectedMob)
                    end
                end
            end
        else
            print("No child selected or no children available!")
        end
    end
})



local function getChests()
    local chests = {}
    local chestNames = {}
    local index = 1
    for _, item in ipairs(Workspace:WaitForChild("Items"):GetChildren()) do
        if item.Name:match("^Item Chest") and not item:GetAttribute("8721081708ed") then
            table.insert(chests, item)
            table.insert(chestNames, "Chest " .. index)
            index = index + 1
        end
    end
    if #chestNames == 0 then
        table.insert(chestNames, "No chests spawned yet")
    end
    table.sort(chestNames)
    return chests, chestNames
end

local currentChests, currentChestNames = getChests()
local selectedChest = currentChestNames[1] or nil

tab.create_title({
    name = '== CHESTS (Max Fire lvl Required) ==',
    section = 'left'
})

local debounceChest = false
local function updateChestDropdown()
    if debounceChest then return end
    debounceChest = true

    task.delay(0.1, function()
        currentChests, currentChestNames = getChests()
        chestDropdown.options = currentChestNames
        chestDropdown:update()
        debounceChest = false
    end)
end

local chestDropdown = tab.create_multidropdown({
    name = 'Select Chest to Teleport',
    flag = 'select_chest_tp',
    section = 'left',
    option = 'Select Chest',
    options = currentChestNames,
    multi = false,  
    callback = function(selected)
        if #selected > 0 then
            selectedChest = selected[1]  
        else
            selectedChest = nil
        end
    end
})

chestDropdown.update = chestDropdown.update or function(self) end


local itemsFolder = Workspace:WaitForChild("Items")
itemsFolder.ChildAdded:Connect(updateChestDropdown)
itemsFolder.ChildRemoved:Connect(updateChestDropdown)

tab.create_button({
    name = 'Refresh Chest List',
    flag = 'refresh_chest_list',
    section = 'left',
    callback = function()
        updateChestDropdown()
        print("Chest list refreshed!")
    end
})

tab.create_button({
    name = 'Teleport to Selected Chest',
    flag = 'tp_to_chest',
    section = 'left',
    callback = function()
        if selectedChest and selectedChest ~= "No chests spawned yet" and currentChests then
            local chestIndex = 1
            for i, name in ipairs(currentChestNames) do
                if name == selectedChest then
                    chestIndex = i
                    break
                end
            end
            local targetChest = currentChests[chestIndex]
            if targetChest then
                local part = targetChest.PrimaryPart or targetChest:FindFirstChildWhichIsA("BasePart")
                if part and LocalPlayer.Character then
                    local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.CFrame = part.CFrame + Vector3.new(0, 5, 0)
                        print("Teleported to chest: " .. selectedChest)
                    end
                end
            end
        else
            print("No chest selected or no chests available!")
        end
    end
})




tab.create_title({
    name = '== PLAYER TELEPORT ==',
    section = 'left'
})

local teleportTarget = nil

local function updateTeleportPlayers()
    local playersList = {"Select Player"}
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            table.insert(playersList, player.Name)
        end
    end
    return playersList
end

local playerDropdown = tab.create_dropdown({
    name = "Players",
    flag = "TeleportPlayers",
    section = 'left',
    option = "Select Player",
    options = updateTeleportPlayers(),
    callback = function(selected)
        teleportTarget = (selected ~= "Select Player") and game:GetService("Players"):FindFirstChild(selected) or nil
    end
})

tab.create_button({
    name = "Teleport to Player",
    flag = "TeleportToPlayer",
    section = 'left',
    callback = function()
        if teleportTarget and teleportTarget.Character then
            local targetRoot = teleportTarget.Character:FindFirstChild("HumanoidRootPart")
            local localRoot = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetRoot and localRoot then
                localRoot.CFrame = targetRoot.CFrame
            end
        end
    end
})

tab.create_button({
    name = "Update Players List",
    flag = "UpdatePlayersList",
    section = 'left',
    callback = function()
        local currentOptions = playerDropdown.options
        local newOptions = updateTeleportPlayers()
        
       
        playerDropdown.options = newOptions
        playerDropdown:update()
    end
})


tab.create_button({
    name = "Teleport to Random Player",
    flag = "TeleportToRandomPlayer",
    section = 'left',
    callback = function()
        local Players = game:GetService("Players")
        local players = Players:GetPlayers()
        local otherPlayers = {}
        
        for _, p in pairs(players) do
            if p ~= game.Players.LocalPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(otherPlayers, p)
            end
        end
        
        if #otherPlayers > 0 then
            local randomPlayer = otherPlayers[math.random(1, #otherPlayers)]
            local localRoot = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if localRoot then
                localRoot.CFrame = randomPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(5, 0, 0)
            end
        end
    end
})

tab.create_title({
    name = '== EXTRA ==',
    section = 'left'
})
tab.create_button({
    name = 'Teleport To Trader',
    flag = 'Bringlog',

    section = 'left',
    enabled = false,

    callback = function(state: boolean)
    local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HRP = Character:WaitForChild("HumanoidRootPart")

local traderPos = Vector3.new(-37.08, 3.98, -16.33)
HRP.CFrame = CFrame.new(traderPos)
    end
})
tab.create_button({
    name = 'Teleport To Random Tree',
    flag = 'Bringlog',
    section = 'left',
    callback = function()
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local Workspace = game:GetService("Workspace")

        local function teleportToRandomTree()
            local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local map = Workspace:FindFirstChild("Map")
            if not map then return end

            local foliage = map:FindFirstChild("Foliage") or map:FindFirstChild("Landmarks")
            if not foliage then return end

            local trees = {}
            for _, obj in ipairs(foliage:GetChildren()) do
                if obj.Name == "Small Tree" and obj:IsA("Model") then
                    local trunk = obj:FindFirstChild("Trunk") or obj.PrimaryPart
                    if trunk then
                        table.insert(trees, trunk)
                    end
                end
            end

            if #trees > 0 then
                local trunk = trees[math.random(1, #trees)]
                local treeCFrame = trunk.CFrame
                local rightVector = treeCFrame.RightVector
                local targetPosition = treeCFrame.Position + rightVector * 3
                hrp.CFrame = CFrame.new(targetPosition)
            end
        end

        teleportToRandomTree()
    end
})


local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer

local itemFolder = Workspace:WaitForChild("Items")
local map = Workspace:WaitForChild("Map")
local foliage = map:FindFirstChild("Foliage")
local landmarks = map:FindFirstChild("Landmarks")

local hitboxSettings = {
    Enabled = false,
    Size = 30,
    Transparency = 0.5,
    Color = Color3.fromRGB(255, 0, 0),
    UpdateRate = 0.1,
    SelectedTargets = {}
}

local hitboxCache = {} 
local hitboxConnections = {} 

hitboxTab.create_title({
    name = '== HITBOX ==',
    section = 'left'
})

hitboxTab.create_multidropdown({
    name = "Select Target Entity",
    flag = "hitbox_targets",
    section = "left",
    option = "Select targets",
    options = {"Wolf", "Alpha Wolf", "Bunny", "Cultist", "Crossbow Cultist"},
    callback = function(selected)
        hitboxSettings.SelectedTargets = {}
        for _, target in ipairs(selected) do
            hitboxSettings.SelectedTargets[target:lower()] = true
        end
    end
})


hitboxTab.create_toggle({
    name = "Activate Hitbox",
    flag = "hitbox_toggle",
    section = "left",
    enabled = false,
    callback = function(state)
        hitboxSettings.Enabled = state
        
        if state then
            local function shouldModifyHitbox(model)
                local name = model.Name:lower()
                return hitboxSettings.SelectedTargets[name] or
                       (hitboxSettings.SelectedTargets["wolf"] and name:find("wolf")) or
                       (hitboxSettings.SelectedTargets["cultist"] and name:find("cultist"))
            end
            
            local function cleanupHitbox(root)
                if hitboxConnections[root] then
                    hitboxConnections[root]:Disconnect()
                    hitboxConnections[root] = nil
                end
                
                if root and root.Parent then
                    root.Size = root.Size 
                    root.Transparency = 1
                    root.CanCollide = true
                end
                
                hitboxCache[root] = nil
            end
            
            local function setupHitbox(model)
                if not model:IsA("Model") then return end
                local root = model:FindFirstChild("HumanoidRootPart")
                if not root or not shouldModifyHitbox(model) then return end
                
                hitboxCache[root] = true
                
                root.Size = Vector3.new(hitboxSettings.Size, hitboxSettings.Size, hitboxSettings.Size)
                root.Transparency = hitboxSettings.Transparency
                root.Color = hitboxSettings.Color
                root.Material = Enum.Material.Neon
                root.CanCollide = false
                
                if hitboxConnections[root] then
                    hitboxConnections[root]:Disconnect()
                end
                
                hitboxConnections[root] = game:GetService("RunService").Heartbeat:Connect(function()
                    if not root or not root.Parent or not hitboxSettings.Enabled then
                        cleanupHitbox(root)
                        return
                    end
                    
                    root.Size = Vector3.new(hitboxSettings.Size, hitboxSettings.Size, hitboxSettings.Size)
                    root.Transparency = hitboxSettings.Transparency
                    root.Color = hitboxSettings.Color
                    root.CanCollide = false
                end)
            end
            
           
            for _, model in ipairs(workspace:GetDescendants()) do
                if model:IsA("Model") then
                    setupHitbox(model)
                end
            end
            
          
            if not hitboxConnections["DescendantAdded"] then
                hitboxConnections["DescendantAdded"] = workspace.DescendantAdded:Connect(function(descendant)
                    if descendant:IsA("Model") then
                        task.wait(0.1)
                        setupHitbox(descendant)
                    end
                end)
            end
        else
           
            for root, _ in pairs(hitboxCache) do
                if root and root.Parent then
                    root.Size = root.Size 
                    root.Transparency = 1
                    root.CanCollide = true
                end
            end
            
           
            for _, connection in pairs(hitboxConnections) do
                if typeof(connection) == "RBXScriptConnection" then
                    connection:Disconnect()
                end
            end
            
            
            table.clear(hitboxCache)
            table.clear(hitboxConnections)
        end
    end
})


hitboxTab.create_slider({
    name = "Hitbox Size",
    flag = "hitbox_size",
    section = "left",
    value = hitboxSettings.Size,
    minimum_value = 10,
    maximum_value = 200,
    callback = function(value)
        hitboxSettings.Size = value
    end
})
tab3.create_title({
    name = '== VISUAL ==',
    section = 'left'
})
tab3.create_multidropdown({
    name = "Select Entities",
    flag = "entity_esp_dropdown",
    section = "left",
    option = "Select entities to ESP",
    options = ESPSettings.EntityESP.Entities,
    callback = function(selected)
        ESPSettings.EntityESP.Selected = {}
        for _, name in ipairs(selected) do
            ESPSettings.EntityESP.Selected[name] = true
        end
        if ESPSettings.EntityESP.Enabled then
            updateESP("EntityESP")
        end
    end
})

tab3.create_toggle({
    name = "Activate Entity ESP",
    flag = "entity_esp_toggle",
    section = "left",
    enabled = false,
    callback = function(state)
        ESPSettings.EntityESP.Enabled = state
        updateESP("EntityESP")
        
        if state then
            if not ESPConnections.Entities then
                ESPConnections.Entities = Workspace.Characters.ChildAdded:Connect(function(child)
                    task.wait(0.1)
                    if ESPSettings.EntityESP.Selected["All"] or ESPSettings.EntityESP.Selected[child.Name] then
                        local part = child:FindFirstChildWhichIsA("BasePart")
                        if part then
                            createESPText(part, child.Name, ESPSettings.EntityESP.Color)
                        end
                    end
                end)
            end
        else
            if ESPConnections.Entities then
                ESPConnections.Entities:Disconnect()
                ESPConnections.Entities = nil
            end
        end
    end
})


tab3.create_multidropdown({
    name = "Select Items",
    flag = "item_esp_dropdown",
    section = "left",
    option = "Select items to ESP",
    options = ESPSettings.ItemESP.Items,
    callback = function(selected)
        ESPSettings.ItemESP.Selected = {}
        for _, name in ipairs(selected) do
            ESPSettings.ItemESP.Selected[name] = true
        end
        if ESPSettings.ItemESP.Enabled then
            updateESP("ItemESP")
        end
    end
})

tab3.create_toggle({
    name = "Activate Item ESP",
    flag = "item_esp_toggle",
    section = "left",
    enabled = false,
    callback = function(state)
        ESPSettings.ItemESP.Enabled = state
        updateESP("ItemESP")
        
        if state then
            if not ESPConnections.Items then
                ESPConnections.Items = Workspace.Items.ChildAdded:Connect(function(child)
                    task.wait(0.1)
                    if ESPSettings.ItemESP.Selected["All"] or ESPSettings.ItemESP.Selected[child.Name] then
                        local part = child:FindFirstChildWhichIsA("BasePart")
                        if part then
                            createESPText(part, child.Name, ESPSettings.ItemESP.Color)
                        end
                    end
                end)
            end
        else
            if ESPConnections.Items then
                ESPConnections.Items:Disconnect()
                ESPConnections.Items = nil
            end
        end
    end
})


local UIS = game:GetService("UserInputService")

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")

local localPlayer = Players.LocalPlayer
local infJumpConnection = nil
local infJumpDebounce = false

tab2.create_toggle({
    name = 'Infinite Jump',
    flag = 'infjump_toggle',
    section = 'left',
    enabled = false,

    callback = function(state: boolean)
        if state then
           
            if infJumpConnection then
                infJumpConnection:Disconnect()
            end

            infJumpDebounce = false
            infJumpConnection = UserInputService.JumpRequest:Connect(function()
                if not infJumpDebounce then
                    local character = localPlayer.Character
                    if character then
                        local humanoid = character:FindFirstChildWhichIsA("Humanoid")
                        if humanoid then
                            infJumpDebounce = true
                            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                            task.wait()
                            infJumpDebounce = false
                        end
                    end
                end
            end)
        else
            
            if infJumpConnection then
                infJumpConnection:Disconnect()
                infJumpConnection = nil
            end
            infJumpDebounce = false
        end
    end
})

local Plr = game.Players.LocalPlayer
local Camera = game.Workspace.CurrentCamera

getgenv().flyspeed = getgenv().flyspeed or 50
getgenv().fly = getgenv().fly or false

if not Plr.Character then
    Plr.CharacterAdded:Wait()
end

local HRP = Plr.Character:WaitForChild("HumanoidRootPart")

local GetMoveVector = require(Plr:WaitForChild("PlayerScripts").PlayerModule:WaitForChild("ControlModule")) 

local FlyForce

game["Run Service"].RenderStepped:Connect(function()
    if getgenv().fly then
        if not FlyForce then
            FlyForce = Instance.new("BodyVelocity")
            FlyForce.MaxForce = Vector3.new(1e5, 1e5, 1e5)
            FlyForce.Parent = HRP
        end
        FlyForce.Velocity = Vector3.new()
        local MoveDir = GetMoveVector:GetMoveVector()
        local Speed = getgenv().flyspeed or 50
        if MoveDir.X ~= 0 then
            FlyForce.Velocity = FlyForce.Velocity + Camera.CFrame.RightVector * MoveDir.X * Speed
        end
        if MoveDir.Z ~= 0 then
            FlyForce.Velocity = FlyForce.Velocity - Camera.CFrame.LookVector * MoveDir.Z * Speed
        end
    else
        if FlyForce then
            FlyForce:Destroy()
            FlyForce = nil
        end
    end
end)

tab2.create_toggle({
    name = 'Fly',
    flag = 'fly',
    section = 'left',
    enabled = false,
    callback = function(state)
       if state then getgenv().fly = true else getgenv().fly = false end
    end
})

tab2.create_slider({
    name = 'Fly Speed',
    flag = 'sliderflagname',
    section = 'left',
    value = 35,
    minimum_value = 10,
    maximum_value = 1000,
    callback = function(value)
        getgenv().flyspeed = value
    end
})

tab2.create_slider({
    name = 'Walkspeed',
    flag = 'flyspeed',

    section = 'left',

    value = getgenv().speedValue or 28,
    minimum_value = 10,
    maximum_value = 1000,

    callback = function(value: number)
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer



        getgenv().speedValue = value

            local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = getgenv().speedValue
            end
       
            end
})
local RunService = game:GetService("RunService")

local NoclippingConnection = nil
local Clip = true 

local function noclipOn(character)
    Clip = false
    if NoclippingConnection then
        NoclippingConnection:Disconnect()
    end
    NoclippingConnection = RunService.Stepped:Connect(function()
        if not Clip and character then
            for _, child in pairs(character:GetDescendants()) do
                if child:IsA("BasePart") and child.CanCollide == true then
                    child.CanCollide = false
                end
            end
        end
    end)
end

local function noclipOff(character)
    Clip = true
    if NoclippingConnection then
        NoclippingConnection:Disconnect()
        NoclippingConnection = nil
    end
    if character then
        for _, child in pairs(character:GetDescendants()) do
            if child:IsA("BasePart") then
                child.CanCollide = true
            end
        end
    end
end





local defaultGravity = workspace.Gravity
local defaultFOV = game.Workspace.CurrentCamera.FieldOfView


tab2.create_slider({
    name = "Gravity",
    flag = "Gravity",
    section = 'left',
    value = workspace.Gravity,
    minimum_value = 0,
    maximum_value = 999,
    callback = function(value)
        workspace.Gravity = value
    end
})



tab2.create_slider({
    name = "FOV",
    flag = "FOV",
    section = 'left',
    value = game.Workspace.CurrentCamera.FieldOfView,
    minimum_value = 20,
    maximum_value = 120,
    callback = function(value)
        game.Workspace.CurrentCamera.FieldOfView = value
    end
})


tab2.create_toggle({
    name = "Noclip",
    flag = "noclipToggle",
    section = "left",
    enabled = false,

    callback = function(state)
        local player = game.Players.LocalPlayer
        if not player or not player.Character then return end
        if state then
            noclipOn(player.Character)
           
        else
            noclipOff(player.Character)
            
        end
    end
})

tab2.create_button({
    name = 'Instant Interact',
    flag = 'Bringlog',

    section = 'left',
    enabled = false,

    callback = function(state: boolean)
      local function setupPrompt(p)
                if p:IsA("ProximityPrompt") then
                    p.RequiresLineOfSight = false
                    p.MaxActivationDistance = 15
                    p.HoldDuration = 0
                   
                end
            end

            for _, p in ipairs(workspace:GetDescendants()) do setupPrompt(p) end
            workspace.DescendantAdded:Connect(setupPrompt)
    end
})



tab2.create_title({
    name = '== CIRCLE UNANCHORED PARTS [FE] ==',
    section = 'left'
})


local radius = 50  
local rotationSpeed = 0.5  
local attractionStrength = 1000  
local ringPartsEnabled = false  
local parts = {}


if not getgenv().Network then  
    getgenv().Network = { 
        BaseParts = {}, 
        Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424),
        Enabled = false
    }  

    Network.RetainPart = function(Part)  
        if not Network.Enabled then return end
        if typeof(Part) == "Instance" and Part:IsA("BasePart") and Part:IsDescendantOf(workspace) then  
            table.insert(Network.BaseParts, Part)  
            Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)  
            Part.CanCollide = false  
        end  
    end  

    local function EnablePartControl()  
        if not Network.Enabled then return end 
        game.Players.LocalPlayer.ReplicationFocus = workspace  
        game:GetService("RunService").Heartbeat:Connect(function()  
            sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)  
            for _, Part in pairs(Network.BaseParts) do  
                if Part:IsDescendantOf(workspace) then  
                    Part.Velocity = Network.Velocity  
                end  
            end  
        end)  
    end  

   
end


local parts = {}
local function RetainPart(Part)  
    if not ringPartsEnabled then return false end 
    if Part:IsA("BasePart") and not Part.Anchored and Part:IsDescendantOf(workspace) then  
        if Part.Parent == game.Players.LocalPlayer.Character or Part:IsDescendantOf(game.Players.LocalPlayer.Character) then return false end  
        Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)  
        Part.CanCollide = false  
        return true  
    end  
    return false  
end  

local function addPart(part)  
    if RetainPart(part) and not table.find(parts, part) then  
        table.insert(parts, part)  
    end  
end  

local function removePart(part)  
    local index = table.find(parts, part)  
    if index then table.remove(parts, index) end  
end


for _, part in pairs(workspace:GetDescendants()) do addPart(part) end  
workspace.DescendantAdded:Connect(addPart)  
workspace.DescendantRemoving:Connect(removePart)  


local RunService = game:GetService("RunService")
local ringConnection = nil

tab2.create_toggle({
    name = 'Activate Unanchored Parts',
    flag = 'ring_parts_toggle',
    section = 'left',
    enabled = false,
    callback = function(state)
        ringPartsEnabled = state
        
        if state then
      for _, part in pairs(workspace:GetDescendants()) do addPart(part) end  
            if not ringConnection then
                ringConnection = RunService.Heartbeat:Connect(function()  
                    local player = game.Players.LocalPlayer
                    local humanoidRootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")  
                    if humanoidRootPart then  
                        local tornadoCenter = humanoidRootPart.Position  
                        for _, part in pairs(parts) do  
                            if part.Parent and not part.Anchored then  
                                local pos = part.Position  
                                local distance = (Vector3.new(pos.X, tornadoCenter.Y, pos.Z) - tornadoCenter).Magnitude  
                                local angle = math.atan2(pos.Z - tornadoCenter.Z, pos.X - tornadoCenter.X)  
                                local newAngle = angle + math.rad(rotationSpeed)  
                                local targetPos = Vector3.new(  
                                    tornadoCenter.X + math.cos(newAngle) * math.min(radius, distance),  
                                    tornadoCenter.Y + (100 * (math.abs(math.sin((pos.Y - tornadoCenter.Y) / 100)))),  
                                    tornadoCenter.Z + math.sin(newAngle) * math.min(radius, distance)
                                )
                                local directionToTarget = (targetPos - part.Position).unit  
                                part.Velocity = directionToTarget * attractionStrength  
                            end  
                        end  
                    end  
                end)
            end
        else
            
            if ringConnection then
                ringConnection:Disconnect()
                ringConnection = nil
            end
         for _, part in pairs(parts) do
                if part and part.Parent then
                    part.CustomPhysicalProperties = nil 
                    part.CanCollide = true  
                end
            end
            table.clear(parts)
        end
    end
})


tab2.create_slider({
    name = 'Circle Radius',
    flag = 'ring_radius',
    section = 'left',
    value = 50,
    minimum_value = 10,
    maximum_value = 100,
    callback = function(value)
        radius = value
    end
})


tab2.create_slider({
    name = 'Rotation Speed',
    flag = 'ring_speed',
    section = 'left',
    value = 0.5,
    minimum_value = 0.1,
    maximum_value = 5,
    callback = function(value)
        rotationSpeed = value
    end
})


tab2.create_slider({
    name = 'Pulling Force',
    flag = 'ring_attraction',
    section = 'left',
    value = 300,
    minimum_value = 100,
    maximum_value = 5000,
    callback = function(value)
        attractionStrength = value
    end
})



local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local selectedFlingPlayer = nil

local function updatePlayersList()
    local list = {"Select Player"}
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            table.insert(list, p.Name)
        end
    end
    return list
end

local playerDropdown = trollTab.create_dropdown({
    name = "Players",
    flag = "troll_players",
    section = "left",
    option = "Select Player",
    options = updatePlayersList(),
    callback = function(selected)
        if selected == "Select Player" then
            selectedFlingPlayer = nil
        else
            selectedFlingPlayer = Players:FindFirstChild(selected)
        end
    end
})

trollTab.create_button({
    name = "Update Players List",
    flag = "troll_update_players",
    section = "left",
    callback = function()
        playerDropdown.options = updatePlayersList()
        if playerDropdown.update then playerDropdown:update() end
    end
})


local function SilentSkidFling(TargetPlayer)
    local Player = Players.LocalPlayer
    local Character = Player and Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer and TargetPlayer.Character
    if not (Character and Humanoid and RootPart and TCharacter) then return end

    local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart or TCharacter:FindFirstChild("HumanoidRootPart")
    local THead = TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle") or nil

    if not TCharacter:FindFirstChildWhichIsA("BasePart") then return end

   
    local oldPos = RootPart.CFrame
    local oldFPDH = workspace.FallenPartsDestroyHeight

    
    if THead then
        workspace.CurrentCamera.CameraSubject = THead
    elseif Handle then
        workspace.CurrentCamera.CameraSubject = Handle
    elseif THumanoid then
        workspace.CurrentCamera.CameraSubject = THumanoid
    end

    local function FPos(BasePart, Pos, Ang)
        if not (RootPart and Character) then return end
        RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
        Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
        RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
        RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
    end

    local function SFBasePart(BasePart)
        local TimeToWait = 2
        local TimeStart = tick()
        local Angle = 0

        repeat
            if not (RootPart and THumanoid) then break end
            if BasePart.Velocity.Magnitude < 50 then
                Angle = Angle + 100
                FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0)); task.wait()
            else
                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0)); task.wait()
                local vmag = (TRootPart and TRootPart.Velocity.Magnitude or 0) / 1.25
                FPos(BasePart, CFrame.new(0, 1.5, vmag), CFrame.Angles(math.rad(90), 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, -vmag), CFrame.Angles(0, 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(0, 1.5, vmag), CFrame.Angles(math.rad(90), 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0)); task.wait()
                FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0)); task.wait()
            end
        until BasePart.Velocity.Magnitude > 500
            or BasePart.Parent ~= TargetPlayer.Character
            or TargetPlayer.Parent ~= Players
            or not (TargetPlayer.Character == TCharacter)
            or (THumanoid and THumanoid.Sit)
            or (Humanoid and Humanoid.Health <= 0)
            or tick() > TimeStart + TimeToWait
    end

    workspace.FallenPartsDestroyHeight = 0/0

    local BV = Instance.new("BodyVelocity")
    BV.Name = "EpixVel"
    BV.Parent = RootPart
    BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
    BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    if TRootPart and THead then
        if (TRootPart.CFrame.Position - THead.CFrame.Position).Magnitude > 5 then
            SFBasePart(THead)
        else
            SFBasePart(TRootPart)
        end
    elseif TRootPart and not THead then
        SFBasePart(TRootPart)
    elseif not TRootPart and THead then
        SFBasePart(THead)
    elseif not TRootPart and not THead and Handle then
        SFBasePart(Handle)
    end

    BV:Destroy()
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    workspace.CurrentCamera.CameraSubject = Humanoid

    repeat
        if not (Character and RootPart and Humanoid) then break end
        local targetCFrame = oldPos * CFrame.new(0, .5, 0)
        RootPart.CFrame = targetCFrame
        Character:SetPrimaryPartCFrame(targetCFrame)
        Humanoid:ChangeState("GettingUp")
        for _, x in ipairs(Character:GetChildren()) do
            if x:IsA("BasePart") then
                x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
            end
        end
        task.wait()
    until (RootPart.Position - oldPos.Position).Magnitude < 25

    workspace.FallenPartsDestroyHeight = oldFPDH
end

trollTab.create_button({
    name = "Fling Selected Player",
    flag = "troll_fling_player",
    section = "left",
    callback = function()
        if selectedFlingPlayer then
            SilentSkidFling(selectedFlingPlayer)
        end
    end
})

trollTab.create_button({
    name = "Fling All Players",
    flag = "troll_fling_all",
    section = "left",
    callback = function()
        for _, target in pairs(Players:GetPlayers()) do
            if target ~= LocalPlayer then
                SilentSkidFling(target)
                task.wait(0.1)
            end
        end
    end
})


local walkflinging = false

local function startFling(char)
    local Root = char:WaitForChild("HumanoidRootPart")
    local Humanoid = char:WaitForChild("Humanoid")
    walkflinging = true
    Root.CanCollide = false
    Humanoid:ChangeState(11)
    spawn(function()
        while walkflinging and Root and Root.Parent do
            RunService.Heartbeat:Wait()
            local vel = Root.Velocity
            Root.Velocity = vel * 99999999 + Vector3.new(0, 99999999, 0)
            RunService.RenderStepped:Wait()
            Root.Velocity = vel
            RunService.Stepped:Wait()
            Root.Velocity = vel + Vector3.new(0, 0.1, 0)
        end
    end)
end

local function EnableWalkFling()
    local character = LocalPlayer.Character
    if not character then return end
    walkflinging = true
    startFling(character)
    LocalPlayer.CharacterAdded:Connect(function(char) 
        if walkflinging then
            startFling(char)
        end
    end)
end

local function DisableWalkFling()
    walkflinging = false
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        char.HumanoidRootPart.CanCollide = true
    end
end

local walkFlingToggle = false
trollTab.create_toggle({
    name = "WalkFling",
    flag = "troll_walkfling",
    section = "left",
    enabled = false,
    callback = function(state)
        walkFlingToggle = state
        if state then
            EnableWalkFling()
        else
            DisableWalkFling()
        end
    end
})


local antiFlingConnection = nil
local VELOCITY_THRESHOLD = 50

local function onHeartbeat()
    local character = LocalPlayer.Character
    if not character or not character.Parent then return end
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.CanCollide = false
            if part.Velocity.magnitude > VELOCITY_THRESHOLD then
                part.Velocity = Vector3.new(0, 0, 0)
            end
        end
    end
end

local function restoreCharacter()
    local character = LocalPlayer.Character
    if not character or not character.Parent then return end
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.CanCollide = true
        end
    end
end

local function toggleAntiFling(enable)
    if enable then
        if antiFlingConnection and antiFlingConnection.Connected then return end
        antiFlingConnection = RunService.Heartbeat:Connect(onHeartbeat)
    else
        if antiFlingConnection then
            antiFlingConnection:Disconnect()
            antiFlingConnection = nil
        end
        restoreCharacter()
    end
end

local antiFlingEnabled = false
trollTab.create_toggle({
    name = "Anti Fling",
    flag = "troll_antifling",
    section = "left",
    enabled = false,
    callback = function(state)
        antiFlingEnabled = state
        toggleAntiFling(state)
    end
})


local antiVoidConnection = nil
local positionConnection = nil
local velocityConnection = nil
local lastSafePosition = nil

local function EnableAntiVoid()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = char:WaitForChild("HumanoidRootPart")
    lastSafePosition = humanoidRootPart.CFrame
    antiVoidConnection = RunService.Heartbeat:Connect(function()
        if humanoidRootPart.Position.Y < -100 or humanoidRootPart.Position.Y > 400 then
            humanoidRootPart.CFrame = lastSafePosition
        end
    end)
    positionConnection = RunService.Heartbeat:Connect(function()
        if humanoidRootPart.Velocity.magnitude < 50 and humanoidRootPart.RotVelocity.magnitude < 50 then
            lastSafePosition = humanoidRootPart.CFrame
        end
    end)
    velocityConnection = RunService.Stepped:Connect(function()
        if humanoidRootPart.Velocity.magnitude > 50 then
            humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
        end
        if humanoidRootPart.RotVelocity.magnitude > 50 then
            humanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
        end
    end)
end

local function DisableAntiVoid()
    if antiVoidConnection then
        antiVoidConnection:Disconnect()
        antiVoidConnection = nil
    end
    if positionConnection then
        positionConnection:Disconnect()
        positionConnection = nil
    end
    if velocityConnection then
        velocityConnection:Disconnect()
        velocityConnection = nil
    end
end

local antiVoidEnabled = false
trollTab.create_toggle({
    name = "Anti Void",
    flag = "troll_antivoid",
    section = "left",
    enabled = false,
    callback = function(state)
        antiVoidEnabled = state
        if state then
            EnableAntiVoid()
        else
            DisableAntiVoid()
        end
    end
})

local key = Enum.KeyCode.X


local invis_on = false
local defaultSpeed = 16
local boostedSpeed = 48 
local isSpeedBoosted = false


local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer




local currentInvisSpeedGUI = nil


local function resetInvisibility()
    if invis_on then
        local invisChair = workspace:FindFirstChild('invischair')
        if invisChair then
            invisChair:Destroy()
        end
        
        local character = player.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") or part:IsA("Decal") then
                    part.Transparency = 0
                end
            end
        end
        
        invis_on = false
    end
end


local function resetSpeed()
    if isSpeedBoosted then
        local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = defaultSpeed
        end
        isSpeedBoosted = false
    end
end


local function createInvisSpeedGUI()
    
    if currentInvisSpeedGUI and currentInvisSpeedGUI.Parent then
        return currentInvisSpeedGUI
    end
    
    local G2L = {}
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "InvisSpeedPopup"
    screenGui.Parent = game.Players.LocalPlayer.PlayerGui
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.ResetOnSpawn = false

    local FRAME_SIZE = Vector2.new(180, 150)
    local SHADOW_OFFSET = Vector2.new(15, 15)
    local SHADOW_SIZE = FRAME_SIZE + SHADOW_OFFSET
    local TOP_RIGHT_POSITION = UDim2.new(1, -190, 0, 10)
    local ACCENT_COLOR = Color3.fromRGB(88, 101, 242)

  
    G2L["s"] = Instance.new("ImageLabel", screenGui)
    G2L["s"]["Name"] = "Shadow"
    G2L["s"]["AnchorPoint"] = Vector2.new(1, 0)
    G2L["s"]["Position"] = TOP_RIGHT_POSITION
    G2L["s"]["Size"] = UDim2.fromOffset(SHADOW_SIZE.X, SHADOW_SIZE.Y)
    G2L["s"]["BackgroundTransparency"] = 1.0
    G2L["s"]["ZIndex"] = 0
    G2L["s"]["Image"] = "rbxassetid://17290899982"


    G2L["2"] = Instance.new("Frame", screenGui)
    G2L["2"]["Name"] = "MainFrame"
    G2L["2"]["Active"] = true
    G2L["2"]["AnchorPoint"] = Vector2.new(1, 0)
    G2L["2"]["Position"] = TOP_RIGHT_POSITION
    G2L["2"]["Size"] = UDim2.fromOffset(FRAME_SIZE.X, FRAME_SIZE.Y)
    G2L["2"]["BackgroundColor3"] = Color3.fromRGB(19, 20, 24)
    G2L["2"]["BorderSizePixel"] = 0
    G2L["2"]["ClipsDescendants"] = true
    G2L["2"]["ZIndex"] = 1

    G2L["7"] = Instance.new("UICorner", G2L["2"])
    G2L["7"]["CornerRadius"] = UDim.new(0, 12)

   
    G2L["CloseButton"] = Instance.new("ImageButton", G2L["2"])
    G2L["CloseButton"]["Size"] = UDim2.new(0, 20, 0, 20)
    G2L["CloseButton"]["Position"] = UDim2.new(1, -10, 0, 5)
    G2L["CloseButton"]["AnchorPoint"] = Vector2.new(1, 0)
    G2L["CloseButton"]["BackgroundColor3"] = Color3.fromRGB(45, 45, 50)
    G2L["CloseButton"]["BorderSizePixel"] = 0
    G2L["CloseButton"]["AutoButtonColor"] = false
    G2L["CloseButton"]["Image"] = "rbxassetid://133495621202705"
    G2L["CloseButton"]["ImageColor3"] = Color3.fromRGB(200, 200, 200)

    local CloseCorner = Instance.new("UICorner", G2L["CloseButton"])
    CloseCorner["CornerRadius"] = UDim.new(1, 10)

    local CloseStroke = Instance.new("UIStroke", G2L["CloseButton"])
    CloseStroke["Color"] = Color3.fromRGB(60, 60, 60)
    CloseStroke["Thickness"] = 1
    CloseStroke["Transparency"] = 0.5

 
    G2L["Title"] = Instance.new("TextLabel", G2L["2"])
    G2L["Title"]["Size"] = UDim2.new(1, -30, 0, 25)
    G2L["Title"]["Position"] = UDim2.new(0, 10, 0, 5)
    G2L["Title"]["BackgroundTransparency"] = 1
    G2L["Title"]["FontFace"] = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.Bold)
    G2L["Title"]["Text"] = "Player Controls"
    G2L["Title"]["TextColor3"] = ACCENT_COLOR
    G2L["Title"]["TextSize"] = 16
    G2L["Title"]["TextWrapped"] = true
    G2L["Title"]["TextXAlignment"] = Enum.TextXAlignment.Left

    local TitleStroke = Instance.new("UIStroke", G2L["Title"])
    TitleStroke["Color"] = ACCENT_COLOR
    TitleStroke["Thickness"] = 1
    TitleStroke["Transparency"] = 0.8


    G2L["InvisButton"] = Instance.new("TextButton", G2L["2"])
    G2L["InvisButton"]["Size"] = UDim2.new(1, -20, 0, 28)
    G2L["InvisButton"]["Position"] = UDim2.new(0.5, 0, 0.35, 0)
    G2L["InvisButton"]["AnchorPoint"] = Vector2.new(0.5, 0.5)
    G2L["InvisButton"]["Text"] = invis_on and "Invisible: ON" or "Invisible: OFF"
    G2L["InvisButton"]["TextColor3"] = Color3.fromRGB(255, 255, 255)
    G2L["InvisButton"]["TextSize"] = 12
    G2L["InvisButton"]["FontFace"] = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
    G2L["InvisButton"]["BorderSizePixel"] = 0
    G2L["InvisButton"]["BackgroundColor3"] = Color3.fromRGB(35, 35, 35)
    G2L["InvisButton"]["AutoButtonColor"] = false
    G2L["InvisButton"]["TextScaled"] = true

    G2L["InvisCorner"] = Instance.new("UICorner", G2L["InvisButton"])
    G2L["InvisCorner"]["CornerRadius"] = UDim.new(0, 8)

    local InvisStroke = Instance.new("UIStroke", G2L["InvisButton"])
    InvisStroke["Color"] = invis_on and Color3.fromRGB(80, 200, 80) or Color3.fromRGB(200, 80, 80)
    InvisStroke["Thickness"] = 1
    InvisStroke["Transparency"] = 0.7

    
    G2L["SpeedButton"] = Instance.new("TextButton", G2L["2"])
    G2L["SpeedButton"]["Size"] = UDim2.new(1, -20, 0, 28)
    G2L["SpeedButton"]["Position"] = UDim2.new(0.5, 0, 0.6, 0)
    G2L["SpeedButton"]["AnchorPoint"] = Vector2.new(0.5, 0.5)
    G2L["SpeedButton"]["Text"] = isSpeedBoosted and "Speed Boost: ON" or "Speed Boost: OFF"
    G2L["SpeedButton"]["TextColor3"] = Color3.fromRGB(255, 255, 255)
    G2L["SpeedButton"]["TextSize"] = 12
    G2L["SpeedButton"]["FontFace"] = Font.new("rbxasset://fonts/families/Montserrat.json", Enum.FontWeight.SemiBold)
    G2L["SpeedButton"]["BorderSizePixel"] = 0
    G2L["SpeedButton"]["BackgroundColor3"] = Color3.fromRGB(35, 35, 35)
    G2L["SpeedButton"]["AutoButtonColor"] = false
    G2L["SpeedButton"]["TextScaled"] = true

    G2L["SpeedCorner"] = Instance.new("UICorner", G2L["SpeedButton"])
    G2L["SpeedCorner"]["CornerRadius"] = UDim.new(0, 8)

    local SpeedStroke = Instance.new("UIStroke", G2L["SpeedButton"])
    SpeedStroke["Color"] = isSpeedBoosted and Color3.fromRGB(80, 200, 80) or Color3.fromRGB(200, 80, 80)
    SpeedStroke["Thickness"] = 1
    SpeedStroke["Transparency"] = 0.7



 
    task.spawn(function()
        local popInTime = 0.4
        local popInTweenInfo = TweenInfo.new(popInTime, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
        G2L["2"].Size, G2L["s"].Size = UDim2.fromOffset(0,0), UDim2.fromOffset(0,0)
        G2L["2"].BackgroundTransparency, G2L["s"].ImageTransparency = 1, 1
        
        local frameTween = TweenService:Create(G2L["2"], popInTweenInfo, { Size = UDim2.fromOffset(FRAME_SIZE.X, FRAME_SIZE.Y), BackgroundTransparency = 0 })
        local shadowTween = TweenService:Create(G2L["s"], popInTweenInfo, { Size = UDim2.fromOffset(SHADOW_SIZE.X, SHADOW_SIZE.Y), ImageTransparency = 0 })
        frameTween:Play()
        shadowTween:Play()
    end)

    
    local isDragging = false
    local dragStart, frameStart
    
    G2L["2"].InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging, dragStart, frameStart = true, input.Position, G2L["2"].Position
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) and isDragging then
            local delta = input.Position - dragStart
            G2L["2"].Position = UDim2.new(frameStart.X.Scale, frameStart.X.Offset + delta.X, frameStart.Y.Scale, frameStart.Y.Offset + delta.Y)
            G2L["s"].Position = G2L["2"].Position
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = false
        end
    end)

  
    G2L["CloseButton"].MouseButton1Click:Connect(function()
       
      
        local closeTime = 0.3
        local closeTweenInfo = TweenInfo.new(closeTime, Enum.EasingStyle.Circular, Enum.EasingDirection.In)
        
        local frameTween = TweenService:Create(G2L["2"], closeTweenInfo, { Size = UDim2.fromOffset(0,0), BackgroundTransparency = 1 })
        local shadowTween = TweenService:Create(G2L["s"], closeTweenInfo, { Size = UDim2.fromOffset(0,0), ImageTransparency = 1 })
        frameTween:Play()
        shadowTween:Play()
        frameTween.Completed:Connect(function() 
            resetInvisibility()
            resetSpeed()
            screenGui:Destroy()
            currentInvisSpeedGUI = nil
        end)
    end)


    local function setTransparency(character, transparency)
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") or part:IsA("Decal") then
                part.Transparency = transparency
            end
        end
    end

    local function toggleInvisibility()
        invis_on = not invis_on
       
        if invis_on then
            local savedpos = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
            wait()
            game.Players.LocalPlayer.Character:MoveTo(Vector3.new(-25.95, 84, 3537.55))
            wait(.15)
            local Seat = Instance.new('Seat', game.Workspace)
            Seat.Anchored = false
            Seat.CanCollide = false
            Seat.Name = 'invischair'
            Seat.Transparency = 1
            Seat.Position = Vector3.new(-25.95, 84, 3537.55)
            local Weld = Instance.new("Weld", Seat)
            Weld.Part0 = Seat
            Weld.Part1 = game.Players.LocalPlayer.Character:FindFirstChild("Torso") or game.Players.LocalPlayer.Character.UpperTorso
            wait()
            Seat.CFrame = savedpos
            setTransparency(game.Players.LocalPlayer.Character, 0.5)
           
            G2L["InvisButton"].Text = "Invisible: ON"
            InvisStroke.Color = Color3.fromRGB(80, 200, 80)
        else
            local invisChair = workspace:FindFirstChild('invischair')
            if invisChair then
                invisChair:Destroy()
            end
            setTransparency(game.Players.LocalPlayer.Character, 0)
            
            G2L["InvisButton"].Text = "Invisible: OFF"
            InvisStroke.Color = Color3.fromRGB(200, 80, 80)
        end
    end

    local function toggleSpeedBoost()
        isSpeedBoosted = not isSpeedBoosted
        
        local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
        if humanoid then
            if isSpeedBoosted then
                humanoid.WalkSpeed = boostedSpeed
                G2L["SpeedButton"].Text = "Class Boost: ON"
                SpeedStroke.Color = Color3.fromRGB(80, 200, 80)
             
            else
                humanoid.WalkSpeed = defaultSpeed
                G2L["SpeedButton"].Text = "Class Boost: OFF"
                SpeedStroke.Color = Color3.fromRGB(200, 80, 80)
              
            end
        end
    end


    G2L["InvisButton"].MouseButton1Click:Connect(toggleInvisibility)
    G2L["SpeedButton"].MouseButton1Click:Connect(toggleSpeedBoost)

    currentInvisSpeedGUI = screenGui
    return screenGui
end


local function toggleInvisSpeedGUI(state)
    if state then
     
        if not currentInvisSpeedGUI or not currentInvisSpeedGUI.Parent then
            createInvisSpeedGUI()
        end
    else
   
        if currentInvisSpeedGUI and currentInvisSpeedGUI.Parent then
            resetInvisibility()
            resetSpeed()
            currentInvisSpeedGUI:Destroy()
            currentInvisSpeedGUI = nil
        end
    end
end


player.CharacterAdded:Connect(function(character)
    isSpeedBoosted = false
    local humanoid = character:WaitForChild("Humanoid")
    humanoid.WalkSpeed = defaultSpeed
end)

trollTab.create_toggle({
    name = 'Invisible + Class Boost',
    flag = 'player_controls_toggle',
    section = 'left',
    enabled = false,
    callback = function(state)
        toggleInvisSpeedGUI(state)
    end
})


settingsTab.create_toggle({
    name = "Boost FPS",
    flag = "BoostFPS",
    section = 'left',
    enabled = false,
    callback = function(state)
        if state then
            loadstring(game:HttpGet("https://raw.githubusercontent.com/m00ndiety/Visual/refs/heads/main/FPS"))()
        end
    end
})


local fullBrightEnabled = true  
local originalLighting = {}


local lighting = game:GetService("Lighting")

originalLighting.Brightness = lighting.Brightness
originalLighting.Ambient = lighting.Ambient
originalLighting.ColorShift_Bottom = lighting.ColorShift_Bottom
originalLighting.ColorShift_Top = lighting.ColorShift_Top
originalLighting.FogEnd = lighting.FogEnd
originalLighting.FogStart = lighting.FogStart


lighting.Brightness = 5
lighting.Ambient = Color3.new(1, 1, 1)
lighting.ColorShift_Bottom = Color3.new(1, 1, 1)
lighting.ColorShift_Top = Color3.new(1, 1, 1)
lighting.FogEnd = 100000
lighting.FogStart = 100000

settingsTab.create_toggle({
    name = "Full Brightness",
    flag = "FullBrightness",
    section = 'left',
    enabled = true, 
    callback = function(state)
        fullBrightEnabled = state
        local lighting = game:GetService("Lighting")
        if state then
      
            if not originalLighting.Brightness then
                originalLighting.Brightness = lighting.Brightness
                originalLighting.Ambient = lighting.Ambient
                originalLighting.ColorShift_Bottom = lighting.ColorShift_Bottom
                originalLighting.ColorShift_Top = lighting.ColorShift_Top
                originalLighting.FogEnd = lighting.FogEnd
                originalLighting.FogStart = lighting.FogStart
            end
            
           
            lighting.Brightness = 5
            lighting.Ambient = Color3.new(1, 1, 1)
            lighting.ColorShift_Bottom = Color3.new(1, 1, 1)
            lighting.ColorShift_Top = Color3.new(1, 1, 1)
            lighting.FogEnd = 100000
            lighting.FogStart = 100000
        else
         
            lighting.Brightness = originalLighting.Brightness or 1
            lighting.Ambient = originalLighting.Ambient or Color3.new(0, 0, 0)
            lighting.ColorShift_Bottom = originalLighting.ColorShift_Bottom or Color3.new(0, 0, 0)
            lighting.ColorShift_Top = originalLighting.ColorShift_Top or Color3.new(0, 0, 0)
            lighting.FogEnd = originalLighting.FogEnd or 100000
            lighting.FogStart = originalLighting.FogStart or 0
        end
    end
})

local antiAFKEnabled = false
local antiAFKConnection = nil

settingsTab.create_toggle({
    name = "Anti AFK",
    flag = "AntiAFK",
    section = 'left',
    enabled = false,
    callback = function(state)
        antiAFKEnabled = state
        if state then
            antiAFKConnection = game:GetService("RunService").Heartbeat:Connect(function()
                pcall(function()
                    local character = game.Players.LocalPlayer.Character
                    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid:Move(Vector3.new(0, 0, 0))
                    end
                end)
                task.wait(10)
            end)
        else
            if antiAFKConnection then
                antiAFKConnection:Disconnect()
                antiAFKConnection = nil
            end
        end
    end
})


settingsTab.create_title({
    name = 'SERVER CONTROLS',
    section = 'left'
})

settingsTab.create_button({
    name = "Rejoin",
    flag = "Rejoin",
    section = 'left',
    callback = function()
        local ok = pcall(function()
            game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)
        end)
        if not ok then
            
        end
    end
})

settingsTab.create_button({
    name = "Server Hop",
    flag = "ServerHop",
    section = 'left',
    callback = function()
        local placeId = game.PlaceId
        local currentJobId = game.JobId
        local HttpService = game:GetService("HttpService")
        local TeleportService = game:GetService("TeleportService")
        
        local function serverHop()
            local servers = {}
            local success, result = pcall(function()
                return HttpService:JSONDecode(HttpService:GetAsync(
                    "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"
                ))
            end)
            if (success and result and result.data) then
                for _, server in ipairs(result.data) do
                    if (server.id ~= currentJobId) then
                        table.insert(servers, server)
                    end
                end
                if (#servers > 0) then
                    TeleportService:TeleportToPlaceInstance(placeId, servers[math.random(#servers)].id)
                else
                    TeleportService:Teleport(placeId)
                end
            else
                TeleportService:Teleport(placeId)
            end
        end
        pcall(serverHop)
    end
})

settingsTab.create_button({
    name = "Join to Lower Server",
    flag = "JoinLowerServer",
    section = 'left',
    callback = function()
        local placeId = game.PlaceId
        local currentJobId = game.JobId
        local HttpService = game:GetService("HttpService")
        local TeleportService = game:GetService("TeleportService")
        
        local function joinLowerServer()
            local servers = {}
            local success, result = pcall(function()
                return HttpService:JSONDecode(HttpService:GetAsync(
                    "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Asc&limit=100"
                ))
            end)
            if (success and result and result.data) then
                for _, server in ipairs(result.data) do
                    if ((server.id ~= currentJobId) and (server.playing < (server.maxPlayers or 30))) then
                        table.insert(servers, server)
                    end
                end
                table.sort(servers, function(a, b)
                    return a.playing < b.playing
                end)
                if (#servers > 0) then
                    TeleportService:TeleportToPlaceInstance(placeId, servers[1].id)
                else
                    TeleportService:Teleport(placeId)
                end
            else
                TeleportService:Teleport(placeId)
            end
        end
        pcall(joinLowerServer)
    end
})